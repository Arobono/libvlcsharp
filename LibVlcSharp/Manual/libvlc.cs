// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace VideoLAN.LibVLC
{
    /// <summary>Logging messages level.</summary>
    /// <remarks>Future LibVLC versions may define new levels.</remarks>
    public enum LogLevel
    {
        /// <summary>Debug message</summary>
        Debug = 0,
        /// <summary>Important informational message</summary>
        Notice = 2,
        /// <summary>Warning (potential error) message</summary>
        Warning = 3,
        /// <summary>Error message</summary>
        Error = 4
    }

    /// <summary>This structure is opaque. It represents a libvlc instance</summary>
    /// <summary>
    /// <para>Event manager that belongs to a libvlc object, and from whom events can</para>
    /// <para>be received.</para>
    /// </summary>
    /// <summary>Type of a LibVLC event.</summary>
    /// <summary>Callback function notification</summary>
    /// <param name="p_event">the event triggering the callback</param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void LibvlcCallbackT(global::System.IntPtr p_event, global::System.IntPtr p_data);

    public unsafe partial class EventManager
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VideoLAN.LibVLC.EventManager> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VideoLAN.LibVLC.EventManager>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::VideoLAN.LibVLC.EventManager __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::VideoLAN.LibVLC.EventManager(native.ToPointer(), skipVTables);
        }

        internal static global::VideoLAN.LibVLC.EventManager __CreateInstance(global::VideoLAN.LibVLC.EventManager.__Internal native, bool skipVTables = false)
        {
            return new global::VideoLAN.LibVLC.EventManager(native, skipVTables);
        }

        private static void* __CopyValue(global::VideoLAN.LibVLC.EventManager.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::VideoLAN.LibVLC.EventManager.__Internal));
            *(global::VideoLAN.LibVLC.EventManager.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private EventManager(global::VideoLAN.LibVLC.EventManager.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected EventManager(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class Log
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VideoLAN.LibVLC.Log> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VideoLAN.LibVLC.Log>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::VideoLAN.LibVLC.Log __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::VideoLAN.LibVLC.Log(native.ToPointer(), skipVTables);
        }

        internal static global::VideoLAN.LibVLC.Log __CreateInstance(global::VideoLAN.LibVLC.Log.__Internal native, bool skipVTables = false)
        {
            return new global::VideoLAN.LibVLC.Log(native, skipVTables);
        }

        private static void* __CopyValue(global::VideoLAN.LibVLC.Log.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::VideoLAN.LibVLC.Log.__Internal));
            *(global::VideoLAN.LibVLC.Log.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Log(global::VideoLAN.LibVLC.Log.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Log(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    /// <summary>Description of a module.</summary>
    public unsafe partial class ModuleDescription : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr psz_name;

            [FieldOffset(8)]
            internal global::System.IntPtr psz_shortname;

            [FieldOffset(16)]
            internal global::System.IntPtr psz_longname;

            [FieldOffset(24)]
            internal global::System.IntPtr psz_help;

            [FieldOffset(32)]
            internal global::System.IntPtr p_next;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0libvlc_module_description_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VideoLAN.LibVLC.ModuleDescription> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VideoLAN.LibVLC.ModuleDescription>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::VideoLAN.LibVLC.ModuleDescription __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::VideoLAN.LibVLC.ModuleDescription(native.ToPointer(), skipVTables);
        }

        internal static global::VideoLAN.LibVLC.ModuleDescription __CreateInstance(global::VideoLAN.LibVLC.ModuleDescription.__Internal native, bool skipVTables = false)
        {
            return new global::VideoLAN.LibVLC.ModuleDescription(native, skipVTables);
        }

        private static void* __CopyValue(global::VideoLAN.LibVLC.ModuleDescription.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::VideoLAN.LibVLC.ModuleDescription.__Internal));
            *(global::VideoLAN.LibVLC.ModuleDescription.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ModuleDescription(global::VideoLAN.LibVLC.ModuleDescription.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ModuleDescription(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ModuleDescription()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::VideoLAN.LibVLC.ModuleDescription.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ModuleDescription(global::VideoLAN.LibVLC.ModuleDescription _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::VideoLAN.LibVLC.ModuleDescription.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::VideoLAN.LibVLC.ModuleDescription.__Internal*) __Instance) = *((global::VideoLAN.LibVLC.ModuleDescription.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::VideoLAN.LibVLC.ModuleDescription __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte* PszName
        {
            get
            {
                return (sbyte*) ((global::VideoLAN.LibVLC.ModuleDescription.__Internal*) __Instance)->psz_name;
            }

            set
            {
                ((global::VideoLAN.LibVLC.ModuleDescription.__Internal*) __Instance)->psz_name = (global::System.IntPtr) value;
            }
        }

        public sbyte* PszShortname
        {
            get
            {
                return (sbyte*) ((global::VideoLAN.LibVLC.ModuleDescription.__Internal*) __Instance)->psz_shortname;
            }

            set
            {
                ((global::VideoLAN.LibVLC.ModuleDescription.__Internal*) __Instance)->psz_shortname = (global::System.IntPtr) value;
            }
        }

        public sbyte* PszLongname
        {
            get
            {
                return (sbyte*) ((global::VideoLAN.LibVLC.ModuleDescription.__Internal*) __Instance)->psz_longname;
            }

            set
            {
                ((global::VideoLAN.LibVLC.ModuleDescription.__Internal*) __Instance)->psz_longname = (global::System.IntPtr) value;
            }
        }

        public sbyte* PszHelp
        {
            get
            {
                return (sbyte*) ((global::VideoLAN.LibVLC.ModuleDescription.__Internal*) __Instance)->psz_help;
            }

            set
            {
                ((global::VideoLAN.LibVLC.ModuleDescription.__Internal*) __Instance)->psz_help = (global::System.IntPtr) value;
            }
        }

        public string Name => Marshal.PtrToStringAnsi(((__Internal*)__Instance)->psz_name);

        public string Shortname => Marshal.PtrToStringAnsi(((__Internal*)__Instance)->psz_shortname);

        public string Longname => Marshal.PtrToStringAnsi(((__Internal*)__Instance)->psz_longname);
      
        public string Help => Marshal.PtrToStringAnsi(((__Internal*)__Instance)->psz_help);

        public global::VideoLAN.LibVLC.ModuleDescription PNext
        {
            get
            {
                global::VideoLAN.LibVLC.ModuleDescription __result0;
                if (((global::VideoLAN.LibVLC.ModuleDescription.__Internal*) __Instance)->p_next == IntPtr.Zero) __result0 = null;
                else if (global::VideoLAN.LibVLC.ModuleDescription.NativeToManagedMap.ContainsKey(((global::VideoLAN.LibVLC.ModuleDescription.__Internal*) __Instance)->p_next))
                    __result0 = (global::VideoLAN.LibVLC.ModuleDescription) global::VideoLAN.LibVLC.ModuleDescription.NativeToManagedMap[((global::VideoLAN.LibVLC.ModuleDescription.__Internal*) __Instance)->p_next];
                else __result0 = global::VideoLAN.LibVLC.ModuleDescription.__CreateInstance(((global::VideoLAN.LibVLC.ModuleDescription.__Internal*) __Instance)->p_next);
                return __result0;
            }

            set
            {
                ((global::VideoLAN.LibVLC.ModuleDescription.__Internal*) __Instance)->p_next = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class libvlc
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_errmsg")]
            internal static extern global::System.IntPtr LibvlcErrmsg();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_clearerr")]
            internal static extern void LibvlcClearerr();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_printerr")]
            internal static extern global::System.IntPtr LibvlcPrinterr([MarshalAs(UnmanagedType.LPStr)] string fmt);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_release")]
            internal static extern void LibvlcRelease(global::System.IntPtr p_instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_retain")]
            internal static extern void LibvlcRetain(global::System.IntPtr p_instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_add_intf")]
            internal static extern int LibvlcAddIntf(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_set_exit_handler")]
            internal static extern void LibvlcSetExitHandler(global::System.IntPtr p_instance, global::System.IntPtr cb, global::System.IntPtr opaque);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_set_user_agent")]
            internal static extern void LibvlcSetUserAgent(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string name, [MarshalAs(UnmanagedType.LPStr)] string http);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_set_app_id")]
            internal static extern void LibvlcSetAppId(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string id, [MarshalAs(UnmanagedType.LPStr)] string version, [MarshalAs(UnmanagedType.LPStr)] string icon);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_get_version")]
            internal static extern global::System.IntPtr LibvlcGetVersion();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_get_compiler")]
            internal static extern global::System.IntPtr LibvlcGetCompiler();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_get_changeset")]
            internal static extern global::System.IntPtr LibvlcGetChangeset();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_free")]
            internal static extern void LibvlcFree(global::System.IntPtr ptr);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_event_attach")]
            internal static extern int LibvlcEventAttach(global::System.IntPtr p_event_manager, int i_event_type, global::System.IntPtr f_callback, global::System.IntPtr user_data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_event_detach")]
            internal static extern void LibvlcEventDetach(global::System.IntPtr p_event_manager, int i_event_type, global::System.IntPtr f_callback, global::System.IntPtr p_user_data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_event_type_name")]
            internal static extern global::System.IntPtr LibvlcEventTypeName(int event_type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_log_get_context")]
            internal static extern void LibvlcLogGetContext(global::System.IntPtr ctx, sbyte** module, sbyte** file, uint* line);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_log_get_object")]
            internal static extern void LibvlcLogGetObject(global::System.IntPtr ctx, sbyte** name, sbyte** header, ulong* id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_log_unset")]
            internal static extern void LibvlcLogUnset(global::System.IntPtr p_instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_log_set_file")]
            internal static extern void LibvlcLogSetFile(global::System.IntPtr p_instance, global::System.IntPtr stream);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_module_description_list_release")]
            internal static extern void LibvlcModuleDescriptionListRelease(global::System.IntPtr p_list);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_filter_list_get")]
            internal static extern global::System.IntPtr LibvlcAudioFilterListGet(global::System.IntPtr p_instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_filter_list_get")]
            internal static extern global::System.IntPtr LibvlcVideoFilterListGet(global::System.IntPtr p_instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_clock")]
            internal static extern long LibvlcClock();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?libvlc_delay@@YA_J_J@Z")]
            internal static extern long LibvlcDelay(long pts);
        }

        /// <summary>
        /// <para>A human-readable error message for the last LibVLC error in the calling</para>
        /// <para>thread. The resulting string is valid until another error occurs (at least</para>
        /// <para>until the next LibVLC call).</para>
        /// </summary>
        /// <remarks>This will be NULL if there was no error.</remarks>
        public static string LibvlcErrmsg()
        {
            var __ret = __Internal.LibvlcErrmsg();
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>
        /// <para>Clears the LibVLC error status for the current thread. This is optional.</para>
        /// <para>By default, the error status is automatically overridden when a new error</para>
        /// <para>occurs, and destroyed when the thread exits.</para>
        /// </summary>
        public static void LibvlcClearerr()
        {
            __Internal.LibvlcClearerr();
        }

        /// <summary>
        /// <para>Sets the LibVLC error status and message for the current thread.</para>
        /// <para>Any previous error is overridden.</para>
        /// </summary>
        /// <param name="fmt">the format string</param>
        /// <param name="args">the arguments</param>
        /// <returns>a nul terminated string in any case</returns>
        public static string LibvlcPrinterr(string fmt)
        {
            var __ret = __Internal.LibvlcPrinterr(fmt);
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>
        /// <para>Decrement the reference count of a libvlc instance, and destroy it</para>
        /// <para>if it reaches zero.</para>
        /// </summary>
        /// <param name="p_instance">the instance to destroy</param>
        public static void LibvlcRelease(global::VideoLAN.LibVLC.Instance p_instance)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            __Internal.LibvlcRelease(__arg0);
        }

        /// <summary>
        /// <para>Increments the reference count of a libvlc instance.</para>
        /// <para>The initial reference count is 1 after libvlc_new() returns.</para>
        /// </summary>
        /// <param name="p_instance">the instance to reference</param>
        public static void LibvlcRetain(global::VideoLAN.LibVLC.Instance p_instance)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            __Internal.LibvlcRetain(__arg0);
        }

        /// <summary>Try to start a user interface for the libvlc instance.</summary>
        /// <param name="p_instance">the instance</param>
        /// <param name="name">interface name, or NULL for default</param>
        /// <returns>0 on success, -1 on error.</returns>
        public static int LibvlcAddIntf(global::VideoLAN.LibVLC.Instance p_instance, string name)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcAddIntf(__arg0, name);
            return __ret;
        }

        /// <summary>
        /// <para>Registers a callback for the LibVLC exit event. This is mostly useful if</para>
        /// <para>the VLC playlist and/or at least one interface are started with</para>
        /// <para>libvlc_playlist_play() or libvlc_add_intf() respectively.</para>
        /// <para>Typically, this function will wake up your application main loop (from</para>
        /// <para>another thread).</para>
        /// </summary>
        /// <param name="p_instance">LibVLC instance</param>
        /// <param name="cb">
        /// <para>callback to invoke when LibVLC wants to exit,</para>
        /// <para>or NULL to disable the exit handler (as by default)</para>
        /// </param>
        /// <param name="opaque">data pointer for the callback</param>
        /// <remarks>
        /// <para>This function should be called before the playlist or interface are</para>
        /// <para>started. Otherwise, there is a small race condition: the exit event could</para>
        /// <para>be raised before the handler is registered.</para>
        /// <para>This function and libvlc_wait() cannot be used at the same time.</para>
        /// </remarks>
        public static void LibvlcSetExitHandler(global::VideoLAN.LibVLC.Instance p_instance, global::VideoLAN.LibVLC.Delegates.Action_IntPtr cb, global::System.IntPtr opaque)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __arg1 = cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cb);
            __Internal.LibvlcSetExitHandler(__arg0, __arg1, opaque);
        }

        /// <summary>
        /// <para>Sets the application name. LibVLC passes this as the user agent string</para>
        /// <para>when a protocol requires it.</para>
        /// </summary>
        /// <param name="p_instance">LibVLC instance</param>
        /// <param name="name">human-readable application name, e.g. &quot;FooBar player 1.2.3&quot;</param>
        /// <param name="http">HTTP User Agent, e.g. &quot;FooBar/1.2.3 Python/2.6.0&quot;</param>
        /// <remarks>LibVLC 1.1.1 or later</remarks>
        public static void LibvlcSetUserAgent(global::VideoLAN.LibVLC.Instance p_instance, string name, string http)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            __Internal.LibvlcSetUserAgent(__arg0, name, http);
        }

        /// <summary>
        /// <para>Sets some meta-information about the application.</para>
        /// <para>See also libvlc_set_user_agent().</para>
        /// </summary>
        /// <param name="p_instance">LibVLC instance</param>
        /// <param name="id">Java-style application identifier, e.g. &quot;com.acme.foobar&quot;</param>
        /// <param name="version">application version numbers, e.g. &quot;1.2.3&quot;</param>
        /// <param name="icon">application icon name, e.g. &quot;foobar&quot;</param>
        /// <remarks>LibVLC 2.1.0 or later.</remarks>
        public static void LibvlcSetAppId(global::VideoLAN.LibVLC.Instance p_instance, string id, string version, string icon)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            __Internal.LibvlcSetAppId(__arg0, id, version, icon);
        }

        /// <summary>Retrieve libvlc version.</summary>
        /// <returns>a string containing the libvlc version</returns>
        /// <remarks>Example: &quot;1.1.0-git The Luggage&quot;</remarks>
        public static string LibvlcGetVersion()
        {
            var __ret = __Internal.LibvlcGetVersion();
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>Retrieve libvlc compiler version.</summary>
        /// <returns>a string containing the libvlc compiler version</returns>
        /// <remarks>Example: &quot;gcc version 4.2.3 (Ubuntu 4.2.3-2ubuntu6)&quot;</remarks>
        public static string LibvlcGetCompiler()
        {
            var __ret = __Internal.LibvlcGetCompiler();
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>Retrieve libvlc changeset.</summary>
        /// <returns>a string containing the libvlc changeset</returns>
        /// <remarks>Example: &quot;aa9bce0bc4&quot;</remarks>
        public static string LibvlcGetChangeset()
        {
            var __ret = __Internal.LibvlcGetChangeset();
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>
        /// <para>Frees an heap allocation returned by a LibVLC function.</para>
        /// <para>If you know you're using the same underlying C run-time as the LibVLC</para>
        /// <para>implementation, then you can call ANSI C free() directly instead.</para>
        /// </summary>
        /// <param name="ptr">the pointer</param>
        public static void LibvlcFree(global::System.IntPtr ptr)
        {
            __Internal.LibvlcFree(ptr);
        }

        /// <summary>Register for an event notification.</summary>
        /// <param name="p_event_manager">
        /// <para>the event manager to which you want to attach to.</para>
        /// <para>Generally it is obtained by vlc_my_object_event_manager() where</para>
        /// <para>my_object is the object you want to listen to.</para>
        /// </param>
        /// <param name="i_event_type">the desired event to which we want to listen</param>
        /// <param name="f_callback">the function to call when i_event_type occurs</param>
        /// <param name="user_data">user provided data to carry with the event</param>
        /// <returns>0 on success, ENOMEM on error</returns>
        public static int LibvlcEventAttach(global::VideoLAN.LibVLC.EventManager p_event_manager, int i_event_type, global::VideoLAN.LibVLC.LibvlcCallbackT f_callback, global::System.IntPtr user_data)
        {
            var __arg0 = ReferenceEquals(p_event_manager, null) ? global::System.IntPtr.Zero : p_event_manager.__Instance;
            var __arg2 = f_callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(f_callback);
            var __ret = __Internal.LibvlcEventAttach(__arg0, i_event_type, __arg2, user_data);
            return __ret;
        }

        /// <summary>Unregister an event notification.</summary>
        /// <param name="p_event_manager">the event manager</param>
        /// <param name="i_event_type">the desired event to which we want to unregister</param>
        /// <param name="f_callback">the function to call when i_event_type occurs</param>
        /// <param name="p_user_data">user provided data to carry with the event</param>
        public static void LibvlcEventDetach(global::VideoLAN.LibVLC.EventManager p_event_manager, int i_event_type, global::VideoLAN.LibVLC.LibvlcCallbackT f_callback, global::System.IntPtr p_user_data)
        {
            var __arg0 = ReferenceEquals(p_event_manager, null) ? global::System.IntPtr.Zero : p_event_manager.__Instance;
            var __arg2 = f_callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(f_callback);
            __Internal.LibvlcEventDetach(__arg0, i_event_type, __arg2, p_user_data);
        }

        /// <summary>Get an event's type name.</summary>
        /// <param name="event_type">the desired event</param>
        public static string LibvlcEventTypeName(int event_type)
        {
            var __ret = __Internal.LibvlcEventTypeName(event_type);
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>Gets log message debug infos.</summary>
        /// <param name="ctx">message context (as passed to the</param>
        /// <param name="module">module name storage (or NULL) [OUT]</param>
        /// <param name="file">source code file name storage (or NULL) [OUT]</param>
        /// <param name="line">source code file line number storage (or NULL) [OUT]</param>
        /// <remarks>
        /// <para>This function retrieves self-debug information about a log message:</para>
        /// <para>- the name of the VLC module emitting the message,</para>
        /// <para>- the name of the source code module (i.e. file) and</para>
        /// <para>- the line number within the source code module.</para>
        /// <para>The returned module name and file name will be NULL if unknown.</para>
        /// <para>The returned line number will similarly be zero if unknown.</para>
        /// <para>The returned module name and source code file name, if non-NULL,</para>
        /// <para>are only valid until the logging callback returns.</para>
        /// <para>LibVLC 2.1.0 or later</para>
        /// </remarks>
        public static void LibvlcLogGetContext(global::VideoLAN.LibVLC.Log ctx, sbyte** module, sbyte** file, ref uint line)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            fixed (uint* __refParamPtr3 = &line)
            {
                var __arg3 = __refParamPtr3;
                __Internal.LibvlcLogGetContext(__arg0, module, file, __arg3);
            }
        }

        /// <summary>Gets log message info.</summary>
        /// <param name="ctx">message context (as passed to the</param>
        /// <param name="name">object name storage (or NULL) [OUT]</param>
        /// <param name="header">object header (or NULL) [OUT]</param>
        /// <param name="line">source code file line number storage (or NULL) [OUT]</param>
        /// <remarks>
        /// <para>This function retrieves meta-information about a log message:</para>
        /// <para>- the type name of the VLC object emitting the message,</para>
        /// <para>- the object header if any, and</para>
        /// <para>- a temporaly-unique object identifier.</para>
        /// <para>This information is mainly meant formanualtroubleshooting.</para>
        /// <para>The returned type name may be &quot;generic&quot; if unknown, but it cannot be NULL.</para>
        /// <para>The returned header will be NULL if unset; in current versions, the header</para>
        /// <para>is used to distinguish for VLM inputs.</para>
        /// <para>The returned object ID will be zero if the message is not associated with</para>
        /// <para>any VLC object.</para>
        /// <para>The returned module name and source code file name, if non-NULL,</para>
        /// <para>are only valid until the logging callback returns.</para>
        /// <para>LibVLC 2.1.0 or later</para>
        /// </remarks>
        public static void LibvlcLogGetObject(global::VideoLAN.LibVLC.Log ctx, sbyte** name, sbyte** header, ref ulong id)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            fixed (ulong* __refParamPtr3 = &id)
            {
                var __arg3 = __refParamPtr3;
                __Internal.LibvlcLogGetObject(__arg0, name, header, __arg3);
            }
        }

        /// <summary>Unsets the logging callback.</summary>
        /// <param name="p_instance">libvlc instance</param>
        /// <remarks>
        /// <para>This function deregisters the logging callback for a LibVLC instance.</para>
        /// <para>This is rarely needed as the callback is implicitly unset when the instance</para>
        /// <para>is destroyed.</para>
        /// <para>This function will wait for any pending callbacks invocation to</para>
        /// <para>complete (causing a deadlock if called from within the callback).</para>
        /// <para>LibVLC 2.1.0 or later</para>
        /// </remarks>
        public static void LibvlcLogUnset(global::VideoLAN.LibVLC.Instance p_instance)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            __Internal.LibvlcLogUnset(__arg0);
        }

        /// <summary>Sets up logging to a file.</summary>
        /// <param name="p_instance">libvlc instance</param>
        /// <param name="stream">
        /// <para>FILE pointer opened for writing</para>
        /// <para>(the FILE pointer must remain valid until libvlc_log_unset())</para>
        /// </param>
        /// <remarks>LibVLC 2.1.0 or later</remarks>
        public static void LibvlcLogSetFile(global::VideoLAN.LibVLC.Instance p_instance, global::System.IntPtr stream)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            __Internal.LibvlcLogSetFile(__arg0, stream);
        }

        /// <summary>Release a list of module descriptions.</summary>
        /// <param name="p_list">the list to be released</param>
        public static void LibvlcModuleDescriptionListRelease(global::VideoLAN.LibVLC.ModuleDescription p_list)
        {
            var __arg0 = ReferenceEquals(p_list, null) ? global::System.IntPtr.Zero : p_list.__Instance;
            __Internal.LibvlcModuleDescriptionListRelease(__arg0);
        }

        /// <summary>Returns a list of audio filters that are available.</summary>
        /// <param name="p_instance">libvlc instance</param>
        /// <returns>
        /// <para>a list of module descriptions. It should be freed with libvlc_module_description_list_release().</para>
        /// <para>In case of an error, NULL is returned.</para>
        /// </returns>
        /// <remarks>
        /// <para>libvlc_module_description_t</para>
        /// <para>libvlc_module_description_list_release</para>
        /// </remarks>
        public static global::VideoLAN.LibVLC.ModuleDescription LibvlcAudioFilterListGet(global::VideoLAN.LibVLC.Instance p_instance)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcAudioFilterListGet(__arg0);
            global::VideoLAN.LibVLC.ModuleDescription __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::VideoLAN.LibVLC.ModuleDescription.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::VideoLAN.LibVLC.ModuleDescription) global::VideoLAN.LibVLC.ModuleDescription.NativeToManagedMap[__ret];
            else __result0 = global::VideoLAN.LibVLC.ModuleDescription.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Returns a list of video filters that are available.</summary>
        /// <param name="p_instance">libvlc instance</param>
        /// <returns>
        /// <para>a list of module descriptions. It should be freed with libvlc_module_description_list_release().</para>
        /// <para>In case of an error, NULL is returned.</para>
        /// </returns>
        /// <remarks>
        /// <para>libvlc_module_description_t</para>
        /// <para>libvlc_module_description_list_release</para>
        /// </remarks>
        public static global::VideoLAN.LibVLC.ModuleDescription LibvlcVideoFilterListGet(global::VideoLAN.LibVLC.Instance p_instance)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcVideoFilterListGet(__arg0);
            global::VideoLAN.LibVLC.ModuleDescription __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::VideoLAN.LibVLC.ModuleDescription.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::VideoLAN.LibVLC.ModuleDescription) global::VideoLAN.LibVLC.ModuleDescription.NativeToManagedMap[__ret];
            else __result0 = global::VideoLAN.LibVLC.ModuleDescription.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Return the current time as defined by LibVLC. The unit is the microsecond.</para>
        /// <para>Time increases monotonically (regardless of time zone changes and RTC</para>
        /// <para>adjustements).</para>
        /// <para>The origin is arbitrary but consistent across the whole system</para>
        /// <para>(e.g. the system uptim, the time since the system was booted).</para>
        /// </summary>
        /// <remarks>On systems that support it, the POSIX monotonic clock is used.</remarks>
        public static long LibvlcClock()
        {
            var __ret = __Internal.LibvlcClock();
            return __ret;
        }

        /// <summary>Return the delay (in microseconds) until a certain timestamp.</summary>
        /// <param name="pts">timestamp</param>
        /// <returns>
        /// <para>negative if timestamp is in the past,</para>
        /// <para>positive if it is in the future</para>
        /// </returns>
        public static long LibvlcDelay(long pts)
        {
            var __ret = __Internal.LibvlcDelay(pts);
            return __ret;
        }
    }
}
