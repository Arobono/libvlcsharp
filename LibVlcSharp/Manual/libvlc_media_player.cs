// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace VideoLAN.LibVLC
{
    /// <summary>Description for titles</summary>
    public enum Title
    {
        Menu = 1,
        Interactive = 2
    }

    /// <summary>Marq options definition</summary>
    public enum VideoMarqueeOption
    {
        Enable = 0,
        Text = 1,
        /// <summary>string argument</summary>
        Color = 2,
        /// <summary>string argument</summary>
        Opacity = 3,
        /// <summary>string argument</summary>
        Position = 4,
        /// <summary>string argument</summary>
        Refresh = 5,
        /// <summary>string argument</summary>
        Size = 6,
        /// <summary>string argument</summary>
        Timeout = 7,
        /// <summary>string argument</summary>
        X = 8,
        /// <summary>string argument</summary>
        Y = 9
    }

    /// <summary>Navigation mode</summary>
    public enum NavigationMode
    {
        Activate = 0,
        Up = 1,
        Down = 2,
        Left = 3,
        Right = 4,
        Popup = 5
    }

    /// <summary>Enumeration of values used to set position (e.g. of video title).</summary>
    public enum Position
    {
        Disable = -1,
        Center = 0,
        Left = 1,
        Right = 2,
        Top = 3,
        TopLeft = 4,
        TopRight = 5,
        Bottom = 6,
        BottomLeft = 7,
        BottomRight = 8
    }

    /// <summary>
    /// <para>Enumeration of teletext keys than can be passed via</para>
    /// <para>libvlc_video_set_teletext()</para>
    /// </summary>
    public enum TeletextKey
    {
        Red = 7471104,
        Green = 6750208,
        Yellow = 7929856,
        Blue = 6422528,
        Index = 6881280
    }

    /// <summary>option values for libvlc_video_{get,set}_logo_{int,string}</summary>
    public enum VideoLogoOption
    {
        Enable = 0,
        /// <summary>string argument, &quot;file,d,t;file,d,t;...&quot;</summary>
        File = 1,
        X = 2,
        Y = 3,
        Delay = 4,
        Repeat = 5,
        Opacity = 6,
        Position = 7
    }

    /// <summary>option values for libvlc_video_{get,set}_adjust_{int,float,bool}</summary>
    public enum VideoAdjustOption
    {
        Enable = 0,
        Contrast = 1,
        Brightness = 2,
        Hue = 3,
        Saturation = 4,
        Gamma = 5
    }

    /// <summary>Audio device types</summary>
    public enum AudioOutputDeviceType
    {
        DeviceError = -1,
        DeviceMono = 1,
        DeviceStereo = 2,
        Device2F2R = 4,
        Device3F2R = 5,
        Device5_1 = 6,
        Device6_1 = 7,
        Device7_1 = 8,
        DeviceSPDIF = 10
    }

    /// <summary>Audio channels</summary>
    public enum AudioOutputChannel
    {
        Error = -1,
        Stereo = 1,
        RStereo = 2,
        Left = 3,
        Right = 4,
        Dolbys = 5
    }

    /// <summary>Media player roles.</summary>
    /// <remarks>
    /// <para>LibVLC 3.0.0 and later.</para>
    /// <para>See</para>
    /// </remarks>
    public enum MediaPlayerRole
    {
        /// <summary>Don't use a media player role</summary>
        None = 0,
        /// <summary>Music (or radio) playback</summary>
        Music = 1,
        /// <summary>Video playback</summary>
        Video = 2,
        /// <summary>Speech, real-time communication</summary>
        Communication = 3,
        /// <summary>Video game</summary>
        Game = 4,
        /// <summary>User interaction feedback</summary>
        LiblvcRoleNotification = 5,
        /// <summary>Embedded animation (e.g. in web page)</summary>
        Animation = 6,
        /// <summary>Audio editting/production</summary>
        Production = 7,
        /// <summary>Accessibility</summary>
        Accessibility = 8,
        Test = 9
    }
    
    public unsafe partial class Equalizer
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr NativeReference { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VideoLAN.LibVLC.Equalizer> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VideoLAN.LibVLC.Equalizer>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::VideoLAN.LibVLC.Equalizer __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::VideoLAN.LibVLC.Equalizer(native.ToPointer(), skipVTables);
        }

        internal static global::VideoLAN.LibVLC.Equalizer __CreateInstance(global::VideoLAN.LibVLC.Equalizer.__Internal native, bool skipVTables = false)
        {
            return new global::VideoLAN.LibVLC.Equalizer(native, skipVTables);
        }

        private static void* __CopyValue(global::VideoLAN.LibVLC.Equalizer.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::VideoLAN.LibVLC.Equalizer.__Internal));
            *(global::VideoLAN.LibVLC.Equalizer.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Equalizer(global::VideoLAN.LibVLC.Equalizer.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[NativeReference] = this;
        }

        protected Equalizer(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            NativeReference = new global::System.IntPtr(native);
        }
    }

    /// <summary>
    /// <para>Description for video, audio tracks and subtitles. It contains</para>
    /// <para>id, name (description string) and pointer to next record.</para>
    /// </summary>
    public unsafe partial class TrackDescription : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int i_id;

            [FieldOffset(8)]
            internal global::System.IntPtr psz_name;

            [FieldOffset(16)]
            internal global::System.IntPtr p_next;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0libvlc_track_description_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VideoLAN.LibVLC.TrackDescription> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VideoLAN.LibVLC.TrackDescription>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::VideoLAN.LibVLC.TrackDescription __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::VideoLAN.LibVLC.TrackDescription(native.ToPointer(), skipVTables);
        }

        internal static global::VideoLAN.LibVLC.TrackDescription __CreateInstance(global::VideoLAN.LibVLC.TrackDescription.__Internal native, bool skipVTables = false)
        {
            return new global::VideoLAN.LibVLC.TrackDescription(native, skipVTables);
        }

        private static void* __CopyValue(global::VideoLAN.LibVLC.TrackDescription.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::VideoLAN.LibVLC.TrackDescription.__Internal));
            *(global::VideoLAN.LibVLC.TrackDescription.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TrackDescription(global::VideoLAN.LibVLC.TrackDescription.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TrackDescription(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public TrackDescription()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::VideoLAN.LibVLC.TrackDescription.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public TrackDescription(global::VideoLAN.LibVLC.TrackDescription _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::VideoLAN.LibVLC.TrackDescription.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::VideoLAN.LibVLC.TrackDescription.__Internal*) __Instance) = *((global::VideoLAN.LibVLC.TrackDescription.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::VideoLAN.LibVLC.TrackDescription __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int IId
        {
            get
            {
                return ((global::VideoLAN.LibVLC.TrackDescription.__Internal*) __Instance)->i_id;
            }

            set
            {
                ((global::VideoLAN.LibVLC.TrackDescription.__Internal*) __Instance)->i_id = value;
            }
        }

        public sbyte* PszName
        {
            get
            {
                return (sbyte*) ((global::VideoLAN.LibVLC.TrackDescription.__Internal*) __Instance)->psz_name;
            }

            set
            {
                ((global::VideoLAN.LibVLC.TrackDescription.__Internal*) __Instance)->psz_name = (global::System.IntPtr) value;
            }
        }

        public global::VideoLAN.LibVLC.TrackDescription PNext
        {
            get
            {
                global::VideoLAN.LibVLC.TrackDescription __result0;
                if (((global::VideoLAN.LibVLC.TrackDescription.__Internal*) __Instance)->p_next == IntPtr.Zero) __result0 = null;
                else if (global::VideoLAN.LibVLC.TrackDescription.NativeToManagedMap.ContainsKey(((global::VideoLAN.LibVLC.TrackDescription.__Internal*) __Instance)->p_next))
                    __result0 = (global::VideoLAN.LibVLC.TrackDescription) global::VideoLAN.LibVLC.TrackDescription.NativeToManagedMap[((global::VideoLAN.LibVLC.TrackDescription.__Internal*) __Instance)->p_next];
                else __result0 = global::VideoLAN.LibVLC.TrackDescription.__CreateInstance(((global::VideoLAN.LibVLC.TrackDescription.__Internal*) __Instance)->p_next);
                return __result0;
            }

            set
            {
                ((global::VideoLAN.LibVLC.TrackDescription.__Internal*) __Instance)->p_next = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class TitleDescription : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal long i_duration;

            [FieldOffset(8)]
            internal global::System.IntPtr psz_name;

            [FieldOffset(16)]
            internal uint i_flags;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0libvlc_title_description_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VideoLAN.LibVLC.TitleDescription> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VideoLAN.LibVLC.TitleDescription>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::VideoLAN.LibVLC.TitleDescription __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::VideoLAN.LibVLC.TitleDescription(native.ToPointer(), skipVTables);
        }

        internal static global::VideoLAN.LibVLC.TitleDescription __CreateInstance(global::VideoLAN.LibVLC.TitleDescription.__Internal native, bool skipVTables = false)
        {
            return new global::VideoLAN.LibVLC.TitleDescription(native, skipVTables);
        }

        private static void* __CopyValue(global::VideoLAN.LibVLC.TitleDescription.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::VideoLAN.LibVLC.TitleDescription.__Internal));
            *(global::VideoLAN.LibVLC.TitleDescription.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TitleDescription(global::VideoLAN.LibVLC.TitleDescription.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TitleDescription(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public TitleDescription()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::VideoLAN.LibVLC.TitleDescription.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public TitleDescription(global::VideoLAN.LibVLC.TitleDescription _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::VideoLAN.LibVLC.TitleDescription.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::VideoLAN.LibVLC.TitleDescription.__Internal*) __Instance) = *((global::VideoLAN.LibVLC.TitleDescription.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::VideoLAN.LibVLC.TitleDescription __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public long IDuration
        {
            get
            {
                return ((global::VideoLAN.LibVLC.TitleDescription.__Internal*) __Instance)->i_duration;
            }

            set
            {
                ((global::VideoLAN.LibVLC.TitleDescription.__Internal*) __Instance)->i_duration = value;
            }
        }

        public sbyte* PszName
        {
            get
            {
                return (sbyte*) ((global::VideoLAN.LibVLC.TitleDescription.__Internal*) __Instance)->psz_name;
            }

            set
            {
                ((global::VideoLAN.LibVLC.TitleDescription.__Internal*) __Instance)->psz_name = (global::System.IntPtr) value;
            }
        }

        public uint IFlags
        {
            get
            {
                return ((global::VideoLAN.LibVLC.TitleDescription.__Internal*) __Instance)->i_flags;
            }

            set
            {
                ((global::VideoLAN.LibVLC.TitleDescription.__Internal*) __Instance)->i_flags = value;
            }
        }
    }

    /// <summary>Description for chapters</summary>
    public unsafe partial class ChapterDescription : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal long i_time_offset;

            [FieldOffset(8)]
            internal long i_duration;

            [FieldOffset(16)]
            internal global::System.IntPtr psz_name;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0libvlc_chapter_description_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VideoLAN.LibVLC.ChapterDescription> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VideoLAN.LibVLC.ChapterDescription>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::VideoLAN.LibVLC.ChapterDescription __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::VideoLAN.LibVLC.ChapterDescription(native.ToPointer(), skipVTables);
        }

        internal static global::VideoLAN.LibVLC.ChapterDescription __CreateInstance(global::VideoLAN.LibVLC.ChapterDescription.__Internal native, bool skipVTables = false)
        {
            return new global::VideoLAN.LibVLC.ChapterDescription(native, skipVTables);
        }

        private static void* __CopyValue(global::VideoLAN.LibVLC.ChapterDescription.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::VideoLAN.LibVLC.ChapterDescription.__Internal));
            *(global::VideoLAN.LibVLC.ChapterDescription.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ChapterDescription(global::VideoLAN.LibVLC.ChapterDescription.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ChapterDescription(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ChapterDescription()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::VideoLAN.LibVLC.ChapterDescription.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ChapterDescription(global::VideoLAN.LibVLC.ChapterDescription _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::VideoLAN.LibVLC.ChapterDescription.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::VideoLAN.LibVLC.ChapterDescription.__Internal*) __Instance) = *((global::VideoLAN.LibVLC.ChapterDescription.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::VideoLAN.LibVLC.ChapterDescription __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public long ITimeOffset
        {
            get
            {
                return ((global::VideoLAN.LibVLC.ChapterDescription.__Internal*) __Instance)->i_time_offset;
            }

            set
            {
                ((global::VideoLAN.LibVLC.ChapterDescription.__Internal*) __Instance)->i_time_offset = value;
            }
        }

        public long IDuration
        {
            get
            {
                return ((global::VideoLAN.LibVLC.ChapterDescription.__Internal*) __Instance)->i_duration;
            }

            set
            {
                ((global::VideoLAN.LibVLC.ChapterDescription.__Internal*) __Instance)->i_duration = value;
            }
        }

        public sbyte* PszName
        {
            get
            {
                return (sbyte*) ((global::VideoLAN.LibVLC.ChapterDescription.__Internal*) __Instance)->psz_name;
            }

            set
            {
                ((global::VideoLAN.LibVLC.ChapterDescription.__Internal*) __Instance)->psz_name = (global::System.IntPtr) value;
            }
        }
    }

    /// <summary>
    /// <para>Description for audio output. It contains</para>
    /// <para>name, description and pointer to next record.</para>
    /// </summary>
    public unsafe partial class AudioOutputDescription : IDisposable
    {
        [StructLayout(LayoutKind.Sequential)]
        public partial struct Internal
        {
            internal IntPtr psz_name;

            internal IntPtr psz_description;

            internal IntPtr p_next;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = CallingConvention.Cdecl,
                EntryPoint="??0libvlc_audio_output_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

       

        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VideoLAN.LibVLC.AudioOutputDescription> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VideoLAN.LibVLC.AudioOutputDescription>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::VideoLAN.LibVLC.AudioOutputDescription __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::VideoLAN.LibVLC.AudioOutputDescription(native.ToPointer(), skipVTables);
        }

        internal static global::VideoLAN.LibVLC.AudioOutputDescription __CreateInstance(global::VideoLAN.LibVLC.AudioOutputDescription.Internal native, bool skipVTables = false)
        {
            return new global::VideoLAN.LibVLC.AudioOutputDescription(native, skipVTables);
        }

        private static void* __CopyValue(global::VideoLAN.LibVLC.AudioOutputDescription.Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::VideoLAN.LibVLC.AudioOutputDescription.Internal));
            *(global::VideoLAN.LibVLC.AudioOutputDescription.Internal*) ret = native;
            return ret.ToPointer();
        }

        private AudioOutputDescription(global::VideoLAN.LibVLC.AudioOutputDescription.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected AudioOutputDescription(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public AudioOutputDescription()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::VideoLAN.LibVLC.AudioOutputDescription.Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public AudioOutputDescription(global::VideoLAN.LibVLC.AudioOutputDescription _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::VideoLAN.LibVLC.AudioOutputDescription.Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::VideoLAN.LibVLC.AudioOutputDescription.Internal*) __Instance) = *((global::VideoLAN.LibVLC.AudioOutputDescription.Internal*) _0.__Instance);
        }

      
        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;

            global::VideoLAN.LibVLC.AudioOutputDescription __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        //public string Name => Marshal.PtrToStringAnsi(((Native *) NativeReference)->psz_name);
        public string Name => (string)Utf8StringMarshaler.GetInstance().MarshalNativeToManaged(((Internal *) __Instance)->psz_name);
      
        public string Description => (string)Utf8StringMarshaler.GetInstance().MarshalNativeToManaged(((Internal*)__Instance)->psz_description);
      
        public AudioOutputDescription Next
        {
            get
            {
                global::VideoLAN.LibVLC.AudioOutputDescription __result0;
                if (((global::VideoLAN.LibVLC.AudioOutputDescription.Internal*) __Instance)->p_next == IntPtr.Zero) __result0 = null;
                else if (global::VideoLAN.LibVLC.AudioOutputDescription.NativeToManagedMap.ContainsKey(((global::VideoLAN.LibVLC.AudioOutputDescription.Internal*) __Instance)->p_next))
                    __result0 = (global::VideoLAN.LibVLC.AudioOutputDescription) global::VideoLAN.LibVLC.AudioOutputDescription.NativeToManagedMap[((global::VideoLAN.LibVLC.AudioOutputDescription.Internal*) __Instance)->p_next];
                else __result0 = global::VideoLAN.LibVLC.AudioOutputDescription.__CreateInstance(((global::VideoLAN.LibVLC.AudioOutputDescription.Internal*) __Instance)->p_next);
                return __result0;
            }

            set
            {
                ((global::VideoLAN.LibVLC.AudioOutputDescription.Internal*) __Instance)->p_next = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }
    }
    
    /// <summary>Description for audio output device.</summary>
    public unsafe partial class AudioOutputDevice : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            internal IntPtr p_next;

            [FieldOffset(8)]
            internal IntPtr psz_device;

            [FieldOffset(16)]
            internal IntPtr psz_description;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0libvlc_audio_output_device_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public IntPtr NativeReference { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VideoLAN.LibVLC.AudioOutputDevice> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VideoLAN.LibVLC.AudioOutputDevice>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::VideoLAN.LibVLC.AudioOutputDevice __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::VideoLAN.LibVLC.AudioOutputDevice(native.ToPointer(), skipVTables);
        }

        internal static global::VideoLAN.LibVLC.AudioOutputDevice __CreateInstance(global::VideoLAN.LibVLC.AudioOutputDevice.Internal native, bool skipVTables = false)
        {
            return new global::VideoLAN.LibVLC.AudioOutputDevice(native, skipVTables);
        }

        private static void* __CopyValue(global::VideoLAN.LibVLC.AudioOutputDevice.Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::VideoLAN.LibVLC.AudioOutputDevice.Internal));
            *(global::VideoLAN.LibVLC.AudioOutputDevice.Internal*) ret = native;
            return ret.ToPointer();
        }

        private AudioOutputDevice(global::VideoLAN.LibVLC.AudioOutputDevice.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[NativeReference] = this;
        }

        protected AudioOutputDevice(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            NativeReference = new global::System.IntPtr(native);
        }

        public AudioOutputDevice()
        {
            NativeReference = Marshal.AllocHGlobal(sizeof(global::VideoLAN.LibVLC.AudioOutputDevice.Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[NativeReference] = this;
        }

        public AudioOutputDevice(global::VideoLAN.LibVLC.AudioOutputDevice _0)
        {
            NativeReference = Marshal.AllocHGlobal(sizeof(global::VideoLAN.LibVLC.AudioOutputDevice.Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[NativeReference] = this;
            *((global::VideoLAN.LibVLC.AudioOutputDevice.Internal*) NativeReference) = *((global::VideoLAN.LibVLC.AudioOutputDevice.Internal*) _0.NativeReference);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (NativeReference == IntPtr.Zero)
                return;
            global::VideoLAN.LibVLC.AudioOutputDevice __dummy;
            NativeToManagedMap.TryRemove(NativeReference, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(NativeReference);
            NativeReference = IntPtr.Zero;
        }
        
        public AudioOutputDevice Next
        {
            get
            {
                global::VideoLAN.LibVLC.AudioOutputDevice __result0;
                if (((global::VideoLAN.LibVLC.AudioOutputDevice.Internal*) NativeReference)->p_next == IntPtr.Zero) __result0 = null;
                else if (global::VideoLAN.LibVLC.AudioOutputDevice.NativeToManagedMap.ContainsKey(((global::VideoLAN.LibVLC.AudioOutputDevice.Internal*) NativeReference)->p_next))
                    __result0 = (global::VideoLAN.LibVLC.AudioOutputDevice) global::VideoLAN.LibVLC.AudioOutputDevice.NativeToManagedMap[((global::VideoLAN.LibVLC.AudioOutputDevice.Internal*) NativeReference)->p_next];
                else __result0 = global::VideoLAN.LibVLC.AudioOutputDevice.__CreateInstance(((global::VideoLAN.LibVLC.AudioOutputDevice.Internal*) NativeReference)->p_next);
                return __result0;
            }

            set
            {
                ((global::VideoLAN.LibVLC.AudioOutputDevice.Internal*) NativeReference)->p_next = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.NativeReference;
            }
        }

        public string Device => (string) Utf8StringMarshaler.GetInstance().MarshalNativeToManaged(((Internal*) NativeReference)->psz_device);

        public string Description => (string)Utf8StringMarshaler.GetInstance().MarshalNativeToManaged(((Internal*)NativeReference)->psz_description);
    }
    
    public unsafe partial class libvlc_media_player
    {
        public partial struct __Internal
        {
            

            

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_retain")]
            internal static extern void LibvlcMediaPlayerRetain(global::System.IntPtr p_mi);

       
        
           
            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_set_renderer")]
            internal static extern int LibvlcMediaPlayerSetRenderer(global::System.IntPtr p_mi, global::System.IntPtr p_item);

          
           
            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_set_android_context")]
            internal static extern void LibvlcMediaPlayerSetAndroidContext(global::System.IntPtr p_mi, global::System.IntPtr p_awindow_handler);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_set_evas_object")]
            internal static extern int LibvlcMediaPlayerSetEvasObject(global::System.IntPtr p_mi, global::System.IntPtr p_evas_object);

        
            

           
        
            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_new_viewpoint")]
            internal static extern global::System.IntPtr LibvlcVideoNewViewpoint();

            
           
            
            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_output_list_get")]
            internal static extern global::System.IntPtr LibvlcAudioOutputListGet(global::System.IntPtr p_instance);

         
            
           

         
            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_output_device_get")]
            internal static extern sbyte* LibvlcAudioOutputDeviceGet(global::System.IntPtr mp);

            

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_get_role")]
            internal static extern int LibvlcMediaPlayerGetRole(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_set_role")]
            internal static extern int LibvlcMediaPlayerSetRole(global::System.IntPtr p_mi, uint role);
        }

       

        /// <summary>
        /// <para>Retain a reference to a media player object. Use</para>
        /// <para>libvlc_media_player_release() to decrement reference count.</para>
        /// </summary>
        /// <param name="p_mi">media player object</param>
        //public static void LibvlcMediaPlayerRetain(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    __Internal.LibvlcMediaPlayerRetain(__arg0);
        //}

        

        /// <summary>Get the media used by the media_player.</summary>
        /// <param name="p_mi">the Media Player</param>
        /// <returns>
        /// <para>the media associated with p_mi, or NULL if no</para>
        /// <para>media is associated</para>
        /// </returns>
        //public static global::VideoLAN.LibVLC.Media LibvlcMediaPlayerGetMedia(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcMediaPlayerGetMedia(__arg0);
        //    global::VideoLAN.LibVLC.Media __result0;
        //    if (__ret == IntPtr.Zero) __result0 = null;
        //    else if (global::VideoLAN.LibVLC.Media.NativeToManagedMap.ContainsKey(__ret))
        //        __result0 = (global::VideoLAN.LibVLC.Media) global::VideoLAN.LibVLC.Media.NativeToManagedMap[__ret];
        //    else __result0 = global::VideoLAN.LibVLC.Media.__CreateInstance(__ret);
        //    return __result0;
        //}

        /// <summary>Get the Event Manager from which the media player send event.</summary>
        /// <param name="p_mi">the Media Player</param>
        /// <returns>the event manager associated with p_mi</returns>
        //public static global::VideoLAN.LibVLC.EventManager LibvlcMediaPlayerEventManager(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcMediaPlayerEventManager(__arg0);
        //    global::VideoLAN.LibVLC.EventManager __result0;
        //    if (__ret == IntPtr.Zero) __result0 = null;
        //    else if (global::VideoLAN.LibVLC.EventManager.NativeToManagedMap.ContainsKey(__ret))
        //        __result0 = (global::VideoLAN.LibVLC.EventManager) global::VideoLAN.LibVLC.EventManager.NativeToManagedMap[__ret];
        //    else __result0 = global::VideoLAN.LibVLC.EventManager.__CreateInstance(__ret);
        //    return __result0;
        //}

        /// <summary>is_playing</summary>
        /// <param name="p_mi">the Media Player</param>
        /// <returns>1 if the media player is playing, 0 otherwise</returns>
        //public static int LibvlcMediaPlayerIsPlaying(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcMediaPlayerIsPlaying(__arg0);
        //    return __ret;
        //}

        ///// <summary>Play</summary>
        ///// <param name="p_mi">the Media Player</param>
        ///// <returns>0 if playback started (and was already started), or -1 on error.</returns>
        //public static int LibvlcMediaPlayerPlay(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcMediaPlayerPlay(__arg0);
        //    return __ret;
        //}

        ///// <summary>Pause or resume (no effect if there is no media)</summary>
        ///// <param name="mp">the Media Player</param>
        ///// <param name="do_pause">play/resume if zero, pause if non-zero</param>
        ///// <remarks>LibVLC 1.1.1 or later</remarks>
        //public static void LibvlcMediaPlayerSetPause(global::VideoLAN.LibVLC.MediaPlayer mp, int do_pause)
        //{
        //    var __arg0 = ReferenceEquals(mp, null) ? global::System.IntPtr.Zero : mp.NativeReference;
        //    __Internal.LibvlcMediaPlayerSetPause(__arg0, do_pause);
        //}

        ///// <summary>Toggle pause (no effect if there is no media)</summary>
        ///// <param name="p_mi">the Media Player</param>
        //public static void LibvlcMediaPlayerPause(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    __Internal.LibvlcMediaPlayerPause(__arg0);
        //}

        ///// <summary>Stop (no effect if there is no media)</summary>
        ///// <param name="p_mi">the Media Player</param>
        //public static void LibvlcMediaPlayerStop(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    __Internal.LibvlcMediaPlayerStop(__arg0);
        //}

        ///// <summary>Set a renderer to the media player</summary>
        ///// <param name="p_mi">the Media Player</param>
        ///// <param name="p_item">an item discovered by libvlc_renderer_discoverer_start()</param>
        ///// <returns>0 on success, -1 on error.</returns>
        ///// <remarks>
        ///// <para>must be called before the first call of libvlc_media_player_play() to</para>
        ///// <para>take effect.</para>
        ///// <para>libvlc_renderer_discoverer_new</para>
        ///// <para>LibVLC 3.0.0 or later</para>
        ///// </remarks>
        //public static int LibvlcMediaPlayerSetRenderer(global::VideoLAN.LibVLC.MediaPlayer p_mi, global::VideoLAN.LibVLC.RendererItem p_item)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __arg1 = ReferenceEquals(p_item, null) ? global::System.IntPtr.Zero : p_item.NativeReference;
        //    var __ret = __Internal.LibvlcMediaPlayerSetRenderer(__arg0, __arg1);
        //    return __ret;
        //}

        ///// <summary>
        ///// <para>Set callbacks and private data to render decoded video to a custom area</para>
        ///// <para>in memory.</para>
        ///// <para>Use libvlc_video_set_format() or libvlc_video_set_format_callbacks()</para>
        ///// <para>to configure the decoded format.</para>
        ///// </summary>
        ///// <param name="mp">the media player</param>
        ///// <param name="lock">callback to lock video memory (must not be NULL)</param>
        ///// <param name="unlock">callback to unlock video memory (or NULL if not needed)</param>
        ///// <param name="display">callback to display video (or NULL if not needed)</param>
        ///// <param name="opaque">private pointer for the three callbacks (as first parameter)</param>
        ///// <remarks>
        ///// <para>Rendering video into custom memory buffers is considerably less</para>
        ///// <para>efficient than rendering in a custom window as normal.</para>
        ///// <para>For optimal perfomances, VLC media player renders into a custom window, and</para>
        ///// <para>does not use this function and associated callbacks. It ishighly</para>
        ///// <para>recommendedthat other LibVLC-based application do likewise.</para>
        ///// <para>To embed video in a window, use libvlc_media_player_set_xid() or equivalent</para>
        ///// <para>depending on the operating system.</para>
        ///// <para>If window embedding does not fit the application use case, then a custom</para>
        ///// <para>LibVLC video output display plugin is required to maintain optimal video</para>
        ///// <para>rendering performances.</para>
        ///// <para>The following limitations affect performance:</para>
        ///// <para>- Hardware video decoding acceleration will either be disabled completely,</para>
        ///// <para>or require (relatively slow) copy from video/DSP memory to main memory.</para>
        ///// <para>- Sub-pictures (subtitles, on-screen display, etc.) must be blent into the</para>
        ///// <para>main picture by the CPU instead of the GPU.</para>
        ///// <para>- Depending on the video format, pixel format conversion, picture scaling,</para>
        ///// <para>cropping and/or picture re-orientation, must be performed by the CPU</para>
        ///// <para>instead of the GPU.</para>
        ///// <para>- Memory copying is required between LibVLC reference picture buffers and</para>
        ///// <para>application buffers (between lock and unlock callbacks).</para>
        ///// <para>LibVLC 1.1.1 or later</para>
        ///// </remarks>
        //public static void LibvlcVideoSetCallbacks(global::VideoLAN.LibVLC.MediaPlayer mp, global::VideoLAN.LibVLC.LibvlcVideoLockCb @lock, global::VideoLAN.LibVLC.LibvlcVideoUnlockCb unlock, global::VideoLAN.LibVLC.LibvlcVideoDisplayCb display, global::System.IntPtr opaque)
        //{
        //    var __arg0 = ReferenceEquals(mp, null) ? global::System.IntPtr.Zero : mp.NativeReference;
        //    var __arg1 = @lock == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(@lock);
        //    var __arg2 = unlock == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(unlock);
        //    var __arg3 = display == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(display);
        //    __Internal.LibvlcVideoSetCallbacks(__arg0, __arg1, __arg2, __arg3, opaque);
        //}

        ///// <summary>
        ///// <para>Set decoded video chroma and dimensions.</para>
        ///// <para>This only works in combination with libvlc_video_set_callbacks(),</para>
        ///// <para>and is mutually exclusive with libvlc_video_set_format_callbacks().</para>
        ///// </summary>
        ///// <param name="mp">the media player</param>
        ///// <param name="chroma">
        ///// <para>a four-characters string identifying the chroma</para>
        ///// <para>(e.g. &quot;RV32&quot; or &quot;YUYV&quot;)</para>
        ///// </param>
        ///// <param name="width">pixel width</param>
        ///// <param name="height">pixel height</param>
        ///// <param name="pitch">line pitch (in bytes)</param>
        ///// <remarks>
        ///// <para>LibVLC 1.1.1 or later</para>
        ///// <para>All pixel planes are expected to have the same pitch.</para>
        ///// <para>To use the YCbCr color space with chrominance subsampling,</para>
        ///// <para>consider using libvlc_video_set_format_callbacks() instead.</para>
        ///// </remarks>
        //public static void LibvlcVideoSetFormat(global::VideoLAN.LibVLC.MediaPlayer mp, string chroma, uint width, uint height, uint pitch)
        //{
        //    var __arg0 = ReferenceEquals(mp, null) ? global::System.IntPtr.Zero : mp.NativeReference;
        //    __Internal.LibvlcVideoSetFormat(__arg0, chroma, width, height, pitch);
        //}

        ///// <summary>
        ///// <para>Set decoded video chroma and dimensions. This only works in combination with</para>
        ///// <para>libvlc_video_set_callbacks().</para>
        ///// </summary>
        ///// <param name="mp">the media player</param>
        ///// <param name="setup">callback to select the video format (cannot be NULL)</param>
        ///// <param name="cleanup">callback to release any allocated resources (or NULL)</param>
        ///// <remarks>LibVLC 2.0.0 or later</remarks>
        //public static void LibvlcVideoSetFormatCallbacks(global::VideoLAN.LibVLC.MediaPlayer mp, global::VideoLAN.LibVLC.LibvlcVideoFormatCb setup, global::VideoLAN.LibVLC.LibvlcVideoCleanupCb cleanup)
        //{
        //    var __arg0 = ReferenceEquals(mp, null) ? global::System.IntPtr.Zero : mp.NativeReference;
        //    var __arg1 = setup == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(setup);
        //    var __arg2 = cleanup == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cleanup);
        //    __Internal.LibvlcVideoSetFormatCallbacks(__arg0, __arg1, __arg2);
        //}

        ///// <summary>Set the NSView handler where the media player should render its video output.</summary>
        ///// <param name="p_mi">the Media Player</param>
        ///// <param name="drawable">
        ///// <para>the drawable that is either an NSView or an object following</para>
        ///// <para>the VLCOpenGLVideoViewEmbedding protocol.</para>
        ///// </param>
        ///// <remarks>
        ///// <para>Use the vout called &quot;macosx&quot;.</para>
        ///// <para>The drawable is an NSObject that follow the VLCOpenGLVideoViewEmbedding</para>
        ///// <para>protocol:</para>
        ///// <para>Or it can be an NSView object.</para>
        ///// <para>If you want to use it along with Qt see the QMacCocoaViewContainer. Then</para>
        ///// <para>the following code should work:</para>
        ///// <para>You can find a live example in VLCVideoView in VLCKit.framework.</para>
        ///// </remarks>
        //public static void LibvlcMediaPlayerSetNsobject(global::VideoLAN.LibVLC.MediaPlayer p_mi, global::System.IntPtr drawable)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    __Internal.LibvlcMediaPlayerSetNsobject(__arg0, drawable);
        //}

        ///// <summary>Get the NSView handler previously set with libvlc_media_player_set_nsobject().</summary>
        ///// <param name="p_mi">the Media Player</param>
        ///// <returns>the NSView handler or 0 if none where set</returns>
        //public static global::System.IntPtr LibvlcMediaPlayerGetNsobject(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcMediaPlayerGetNsobject(__arg0);
        //    return __ret;
        //}

        ///// <summary>
        ///// <para>Set an X Window System drawable where the media player should render its</para>
        ///// <para>video output. The call takes effect when the playback starts. If it is</para>
        ///// <para>already started, it might need to be stopped before changes apply.</para>
        ///// <para>If LibVLC was built without X11 output support, then this function has no</para>
        ///// <para>effects.</para>
        ///// </summary>
        ///// <param name="p_mi">media player</param>
        ///// <param name="drawable">X11 window ID</param>
        ///// <remarks>
        ///// <para>By default, LibVLC will capture input events on the video rendering area.</para>
        ///// <para>Use libvlc_video_set_mouse_input() and libvlc_video_set_key_input() to</para>
        ///// <para>disable that and deliver events to the parent window / to the application</para>
        ///// <para>instead. By design, the X11 protocol delivers input events to only one</para>
        ///// <para>recipient.</para>
        ///// <para>The application must call the XInitThreads() function from Xlib before</para>
        ///// <para>libvlc_new(), and before any call to XOpenDisplay() directly or via any</para>
        ///// <para>other library. Failure to call XInitThreads() will seriously impede LibVLC</para>
        ///// <para>performance. Calling XOpenDisplay() before XInitThreads() will eventually</para>
        ///// <para>crash the process. That is a limitation of Xlib.</para>
        ///// <para>The specified identifier must correspond to an existing Input/Output class</para>
        ///// <para>X11 window. Pixmaps arenotcurrently supported. The default X11</para>
        ///// <para>server is assumed, i.e. that specified in the DISPLAY environment variable.</para>
        ///// <para>LibVLC can deal with invalid X11 handle errors, however some display drivers</para>
        ///// <para>(EGL, GLX, VA and/or VDPAU) can unfortunately not. Thus the window handle</para>
        ///// <para>must remain valid until playback is stopped, otherwise the process may</para>
        ///// <para>abort or crash.</para>
        ///// <para>No more than one window handle per media player instance can be specified.</para>
        ///// <para>If the media has multiple simultaneously active video tracks, extra tracks</para>
        ///// <para>will be rendered into external windows beyond the control of the</para>
        ///// <para>application.</para>
        ///// </remarks>
        //public static void LibvlcMediaPlayerSetXwindow(global::VideoLAN.LibVLC.MediaPlayer p_mi, uint drawable)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    __Internal.LibvlcMediaPlayerSetXwindow(__arg0, drawable);
        //}

        ///// <summary>
        ///// <para>Get the X Window System window identifier previously set with</para>
        ///// <para>libvlc_media_player_set_xwindow(). Note that this will return the identifier</para>
        ///// <para>even if VLC is not currently using it (for instance if it is playing an</para>
        ///// <para>audio-only input).</para>
        ///// </summary>
        ///// <param name="p_mi">the Media Player</param>
        ///// <returns>an X window ID, or 0 if none where set.</returns>
        //public static uint LibvlcMediaPlayerGetXwindow(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcMediaPlayerGetXwindow(__arg0);
        //    return __ret;
        //}

        ///// <summary>
        ///// <para>Set a Win32/Win64 API window handle (HWND) where the media player should</para>
        ///// <para>render its video output. If LibVLC was built without Win32/Win64 API output</para>
        ///// <para>support, then this has no effects.</para>
        ///// </summary>
        ///// <param name="p_mi">the Media Player</param>
        ///// <param name="drawable">windows handle of the drawable</param>
        //public static void LibvlcMediaPlayerSetHwnd(global::VideoLAN.LibVLC.MediaPlayer p_mi, global::System.IntPtr drawable)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    __Internal.LibvlcMediaPlayerSetHwnd(__arg0, drawable);
        //}

        ///// <summary>
        ///// <para>Get the Windows API window handle (HWND) previously set with</para>
        ///// <para>libvlc_media_player_set_hwnd(). The handle will be returned even if LibVLC</para>
        ///// <para>is not currently outputting any video to it.</para>
        ///// </summary>
        ///// <param name="p_mi">the Media Player</param>
        ///// <returns>a window handle or NULL if there are none.</returns>
        //public static global::System.IntPtr LibvlcMediaPlayerGetHwnd(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcMediaPlayerGetHwnd(__arg0);
        //    return __ret;
        //}

        ///// <summary>Set the android context.</summary>
        ///// <param name="p_mi">the media player</param>
        ///// <param name="p_awindow_handler">
        ///// <para>org.videolan.libvlc.AWindow jobject owned by the</para>
        ///// <para>org.videolan.libvlc.MediaPlayer class from the libvlc-android project.</para>
        ///// </param>
        ///// <remarks>LibVLC 3.0.0 and later.</remarks>
        //public static void LibvlcMediaPlayerSetAndroidContext(global::VideoLAN.LibVLC.MediaPlayer p_mi, global::System.IntPtr p_awindow_handler)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    __Internal.LibvlcMediaPlayerSetAndroidContext(__arg0, p_awindow_handler);
        //}

        ///// <summary>Set the EFL Evas Object.</summary>
        ///// <param name="p_mi">the media player</param>
        ///// <param name="p_evas_object">a valid EFL Evas Object (Evas_Object)</param>
        ///// <returns>-1 if an error was detected, 0 otherwise.</returns>
        ///// <remarks>LibVLC 3.0.0 and later.</remarks>
        //public static int LibvlcMediaPlayerSetEvasObject(global::VideoLAN.LibVLC.MediaPlayer p_mi, global::System.IntPtr p_evas_object)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcMediaPlayerSetEvasObject(__arg0, p_evas_object);
        //    return __ret;
        //}

        ///// <summary>Sets callbacks and private data for decoded audio.</summary>
        ///// <param name="mp">the media player</param>
        ///// <param name="play">callback to play audio samples (must not be NULL)</param>
        ///// <param name="pause">callback to pause playback (or NULL to ignore)</param>
        ///// <param name="resume">callback to resume playback (or NULL to ignore)</param>
        ///// <param name="flush">callback to flush audio buffers (or NULL to ignore)</param>
        ///// <param name="drain">callback to drain audio buffers (or NULL to ignore)</param>
        ///// <param name="opaque">private pointer for the audio callbacks (as first parameter)</param>
        ///// <remarks>
        ///// <para>Use libvlc_audio_set_format() or libvlc_audio_set_format_callbacks()</para>
        ///// <para>to configure the decoded audio format.</para>
        ///// <para>The audio callbacks override any other audio output mechanism.</para>
        ///// <para>If the callbacks are set, LibVLC willnotoutput audio in any way.</para>
        ///// <para>LibVLC 2.0.0 or later</para>
        ///// </remarks>
        //public static void LibvlcAudioSetCallbacks(global::VideoLAN.LibVLC.MediaPlayer mp, global::VideoLAN.LibVLC.LibvlcAudioPlayCb play, global::VideoLAN.LibVLC.LibvlcAudioPauseCb pause, global::VideoLAN.LibVLC.LibvlcAudioResumeCb resume, global::VideoLAN.LibVLC.LibvlcAudioFlushCb flush, global::VideoLAN.LibVLC.LibvlcAudioDrainCb drain, global::System.IntPtr opaque)
        //{
        //    var __arg0 = ReferenceEquals(mp, null) ? global::System.IntPtr.Zero : mp.NativeReference;
        //    var __arg1 = play == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(play);
        //    var __arg2 = pause == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(pause);
        //    var __arg3 = resume == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(resume);
        //    var __arg4 = flush == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(flush);
        //    var __arg5 = drain == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(drain);
        //    __Internal.LibvlcAudioSetCallbacks(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5, opaque);
        //}

        ///// <summary>
        ///// <para>Set callbacks and private data for decoded audio. This only works in</para>
        ///// <para>combination with libvlc_audio_set_callbacks().</para>
        ///// <para>Use libvlc_audio_set_format() or libvlc_audio_set_format_callbacks()</para>
        ///// <para>to configure the decoded audio format.</para>
        ///// </summary>
        ///// <param name="mp">the media player</param>
        ///// <param name="set_volume">
        ///// <para>callback to apply audio volume,</para>
        ///// <para>or NULL to apply volume in software</para>
        ///// </param>
        ///// <remarks>LibVLC 2.0.0 or later</remarks>
        //public static void LibvlcAudioSetVolumeCallback(global::VideoLAN.LibVLC.MediaPlayer mp, global::VideoLAN.LibVLC.LibvlcAudioSetVolumeCb set_volume)
        //{
        //    var __arg0 = ReferenceEquals(mp, null) ? global::System.IntPtr.Zero : mp.NativeReference;
        //    var __arg1 = set_volume == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(set_volume);
        //    __Internal.LibvlcAudioSetVolumeCallback(__arg0, __arg1);
        //}

        ///// <summary>Sets decoded audio format via callbacks.</summary>
        ///// <param name="mp">the media player</param>
        ///// <param name="setup">callback to select the audio format (cannot be NULL)</param>
        ///// <param name="cleanup">callback to release any allocated resources (or NULL)</param>
        ///// <remarks>
        ///// <para>This only works in combination with libvlc_audio_set_callbacks().</para>
        ///// <para>LibVLC 2.0.0 or later</para>
        ///// </remarks>
        //public static void LibvlcAudioSetFormatCallbacks(global::VideoLAN.LibVLC.MediaPlayer mp, global::VideoLAN.LibVLC.LibvlcAudioSetupCb setup, global::VideoLAN.LibVLC.LibvlcAudioCleanupCb cleanup)
        //{
        //    var __arg0 = ReferenceEquals(mp, null) ? global::System.IntPtr.Zero : mp.NativeReference;
        //    var __arg1 = setup == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(setup);
        //    var __arg2 = cleanup == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cleanup);
        //    __Internal.LibvlcAudioSetFormatCallbacks(__arg0, __arg1, __arg2);
        //}

        ///// <summary>Sets a fixed decoded audio format.</summary>
        ///// <param name="mp">the media player</param>
        ///// <param name="format">
        ///// <para>a four-characters string identifying the sample format</para>
        ///// <para>(e.g. &quot;S16N&quot; or &quot;FL32&quot;)</para>
        ///// </param>
        ///// <param name="rate">sample rate (expressed in Hz)</param>
        ///// <param name="channels">channels count</param>
        ///// <remarks>
        ///// <para>This only works in combination with libvlc_audio_set_callbacks(),</para>
        ///// <para>and is mutually exclusive with libvlc_audio_set_format_callbacks().</para>
        ///// <para>LibVLC 2.0.0 or later</para>
        ///// </remarks>
        //public static void LibvlcAudioSetFormat(global::VideoLAN.LibVLC.MediaPlayer mp, string format, uint rate, uint channels)
        //{
        //    var __arg0 = ReferenceEquals(mp, null) ? global::System.IntPtr.Zero : mp.NativeReference;
        //    __Internal.LibvlcAudioSetFormat(__arg0, format, rate, channels);
        //}

        ///// <summary>Get the current movie length (in ms).</summary>
        ///// <param name="p_mi">the Media Player</param>
        ///// <returns>the movie length (in ms), or -1 if there is no media.</returns>
        //public static long LibvlcMediaPlayerGetLength(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcMediaPlayerGetLength(__arg0);
        //    return __ret;
        //}

        ///// <summary>Get the current movie time (in ms).</summary>
        ///// <param name="p_mi">the Media Player</param>
        ///// <returns>the movie time (in ms), or -1 if there is no media.</returns>
        //public static long LibvlcMediaPlayerGetTime(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcMediaPlayerGetTime(__arg0);
        //    return __ret;
        //}

        ///// <summary>
        ///// <para>Set the movie time (in ms). This has no effect if no media is being played.</para>
        ///// <para>Not all formats and protocols support this.</para>
        ///// </summary>
        ///// <param name="p_mi">the Media Player</param>
        ///// <param name="i_time">the movie time (in ms).</param>
        //public static void LibvlcMediaPlayerSetTime(global::VideoLAN.LibVLC.MediaPlayer p_mi, long i_time)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    __Internal.LibvlcMediaPlayerSetTime(__arg0, i_time);
        //}

        ///// <summary>Get movie position as percentage between 0.0 and 1.0.</summary>
        ///// <param name="p_mi">the Media Player</param>
        ///// <returns>movie position, or -1. in case of error</returns>
        //public static float LibvlcMediaPlayerGetPosition(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcMediaPlayerGetPosition(__arg0);
        //    return __ret;
        //}

        ///// <summary>
        ///// <para>Set movie position as percentage between 0.0 and 1.0.</para>
        ///// <para>This has no effect if playback is not enabled.</para>
        ///// <para>This might not work depending on the underlying input format and protocol.</para>
        ///// </summary>
        ///// <param name="p_mi">the Media Player</param>
        ///// <param name="f_pos">the position</param>
        //public static void LibvlcMediaPlayerSetPosition(global::VideoLAN.LibVLC.MediaPlayer p_mi, float f_pos)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    __Internal.LibvlcMediaPlayerSetPosition(__arg0, f_pos);
        //}

        ///// <summary>Set movie chapter (if applicable).</summary>
        ///// <param name="p_mi">the Media Player</param>
        ///// <param name="i_chapter">chapter number to play</param>
        //public static void LibvlcMediaPlayerSetChapter(global::VideoLAN.LibVLC.MediaPlayer p_mi, int i_chapter)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    __Internal.LibvlcMediaPlayerSetChapter(__arg0, i_chapter);
        //}

        ///// <summary>Get movie chapter.</summary>
        ///// <param name="p_mi">the Media Player</param>
        ///// <returns>chapter number currently playing, or -1 if there is no media.</returns>
        //public static int LibvlcMediaPlayerGetChapter(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcMediaPlayerGetChapter(__arg0);
        //    return __ret;
        //}

        ///// <summary>Get movie chapter count</summary>
        ///// <param name="p_mi">the Media Player</param>
        ///// <returns>number of chapters in movie, or -1.</returns>
        //public static int LibvlcMediaPlayerGetChapterCount(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcMediaPlayerGetChapterCount(__arg0);
        //    return __ret;
        //}

        ///// <summary>Is the player able to play</summary>
        ///// <param name="p_mi">the Media Player</param>
        ///// <returns>boolean</returns>
        //public static int LibvlcMediaPlayerWillPlay(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcMediaPlayerWillPlay(__arg0);
        //    return __ret;
        //}

        ///// <summary>Get title chapter count</summary>
        ///// <param name="p_mi">the Media Player</param>
        ///// <param name="i_title">title</param>
        ///// <returns>number of chapters in title, or -1</returns>
        //public static int LibvlcMediaPlayerGetChapterCountForTitle(global::VideoLAN.LibVLC.MediaPlayer p_mi, int i_title)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcMediaPlayerGetChapterCountForTitle(__arg0, i_title);
        //    return __ret;
        //}

        ///// <summary>Set movie title</summary>
        ///// <param name="p_mi">the Media Player</param>
        ///// <param name="i_title">title number to play</param>
        //public static void LibvlcMediaPlayerSetTitle(global::VideoLAN.LibVLC.MediaPlayer p_mi, int i_title)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    __Internal.LibvlcMediaPlayerSetTitle(__arg0, i_title);
        //}

        ///// <summary>Get movie title</summary>
        ///// <param name="p_mi">the Media Player</param>
        ///// <returns>title number currently playing, or -1</returns>
        //public static int LibvlcMediaPlayerGetTitle(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcMediaPlayerGetTitle(__arg0);
        //    return __ret;
        //}

        ///// <summary>Get movie title count</summary>
        ///// <param name="p_mi">the Media Player</param>
        ///// <returns>title number count, or -1</returns>
        //public static int LibvlcMediaPlayerGetTitleCount(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcMediaPlayerGetTitleCount(__arg0);
        //    return __ret;
        //}

        ///// <summary>Set previous chapter (if applicable)</summary>
        ///// <param name="p_mi">the Media Player</param>
        //public static void LibvlcMediaPlayerPreviousChapter(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    __Internal.LibvlcMediaPlayerPreviousChapter(__arg0);
        //}

        ///// <summary>Set next chapter (if applicable)</summary>
        ///// <param name="p_mi">the Media Player</param>
        //public static void LibvlcMediaPlayerNextChapter(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    __Internal.LibvlcMediaPlayerNextChapter(__arg0);
        //}

        ///// <summary>Get the requested movie play rate.</summary>
        ///// <param name="p_mi">the Media Player</param>
        ///// <returns>movie play rate</returns>
        ///// <remarks>
        ///// <para>Depending on the underlying media, the requested rate may be</para>
        ///// <para>different from the real playback rate.</para>
        ///// </remarks>
        //public static float LibvlcMediaPlayerGetRate(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcMediaPlayerGetRate(__arg0);
        //    return __ret;
        //}

        ///// <summary>Set movie play rate</summary>
        ///// <param name="p_mi">the Media Player</param>
        ///// <param name="rate">movie play rate to set</param>
        ///// <returns>
        ///// <para>-1 if an error was detected, 0 otherwise (but even then, it might</para>
        ///// <para>not actually work depending on the underlying media protocol)</para>
        ///// </returns>
        //public static int LibvlcMediaPlayerSetRate(global::VideoLAN.LibVLC.MediaPlayer p_mi, float rate)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcMediaPlayerSetRate(__arg0, rate);
        //    return __ret;
        //}

        ///// <summary>Get current movie state</summary>
        ///// <param name="p_mi">the Media Player</param>
        ///// <returns>the current state of the media player (playing, paused, ...)</returns>
        ///// <remarks>libvlc_state_t</remarks>
        //public static global::VideoLAN.LibVLC.VLCState LibvlcMediaPlayerGetState(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcMediaPlayerGetState(__arg0);
        //    return __ret;
        //}

        ///// <summary>How many video outputs does this media player have?</summary>
        ///// <param name="p_mi">the media player</param>
        ///// <returns>the number of video outputs</returns>
        //public static uint LibvlcMediaPlayerHasVout(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcMediaPlayerHasVout(__arg0);
        //    return __ret;
        //}

        ///// <summary>Is this media player seekable?</summary>
        ///// <param name="p_mi">the media player</param>
        ///// <returns>true if the media player can seek</returns>
        //public static int LibvlcMediaPlayerIsSeekable(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcMediaPlayerIsSeekable(__arg0);
        //    return __ret;
        //}

        ///// <summary>Can this media player be paused?</summary>
        ///// <param name="p_mi">the media player</param>
        ///// <returns>true if the media player can pause</returns>
        //public static int LibvlcMediaPlayerCanPause(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcMediaPlayerCanPause(__arg0);
        //    return __ret;
        //}

        ///// <summary>Check if the current program is scrambled</summary>
        ///// <param name="p_mi">the media player</param>
        ///// <returns>true if the current program is scrambled</returns>
        ///// <remarks>LibVLC 2.2.0 or later</remarks>
        //public static int LibvlcMediaPlayerProgramScrambled(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcMediaPlayerProgramScrambled(__arg0);
        //    return __ret;
        //}

        ///// <summary>Display the next frame (if supported)</summary>
        ///// <param name="p_mi">the media player</param>
        //public static void LibvlcMediaPlayerNextFrame(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    __Internal.LibvlcMediaPlayerNextFrame(__arg0);
        //}

        ///// <summary>Navigate through DVD Menu</summary>
        ///// <param name="p_mi">the Media Player</param>
        ///// <param name="navigate">the Navigation mode</param>
        ///// <remarks>libVLC 2.0.0 or later</remarks>
        //public static void LibvlcMediaPlayerNavigate(global::VideoLAN.LibVLC.MediaPlayer p_mi, uint navigate)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    __Internal.LibvlcMediaPlayerNavigate(__arg0, navigate);
        //}

        ///// <summary>Set if, and how, the video title will be shown when media is played.</summary>
        ///// <param name="p_mi">the media player</param>
        ///// <param name="position">position at which to display the title, or libvlc_position_disable to prevent the title from being displayed</param>
        ///// <param name="timeout">title display timeout in milliseconds (ignored if libvlc_position_disable)</param>
        ///// <remarks>libVLC 2.1.0 or later</remarks>
        //public static void LibvlcMediaPlayerSetVideoTitleDisplay(global::VideoLAN.LibVLC.MediaPlayer p_mi, global::VideoLAN.LibVLC.Position position, uint timeout)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    __Internal.LibvlcMediaPlayerSetVideoTitleDisplay(__arg0, position, timeout);
        //}

        ///// <summary>Add a slave to the current media player.</summary>
        ///// <param name="p_mi">the media player</param>
        ///// <param name="i_type">subtitle or audio</param>
        ///// <param name="psz_uri">Uri of the slave (should contain a valid scheme).</param>
        ///// <param name="b_select">True if this slave should be selected when it's loaded</param>
        ///// <returns>0 on success, -1 on error.</returns>
        ///// <remarks>
        ///// <para>If the player is playing, the slave will be added directly. This call</para>
        ///// <para>will also update the slave list of the attached libvlc_media_t.</para>
        ///// <para>LibVLC 3.0.0 and later.</para>
        ///// <para>libvlc_media_slaves_add</para>
        ///// </remarks>
        //public static int LibvlcMediaPlayerAddSlave(global::VideoLAN.LibVLC.MediaPlayer p_mi, global::VideoLAN.LibVLC.MediaSlaveType i_type, string psz_uri, bool b_select)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcMediaPlayerAddSlave(__arg0, i_type, psz_uri, b_select);
        //    return __ret;
        //}

        ///// <summary>Release (free) libvlc_track_description_t</summary>
        ///// <param name="p_track_description">the structure to release</param>
        //public static void LibvlcTrackDescriptionListRelease(global::VideoLAN.LibVLC.TrackDescription p_track_description)
        //{
        //    var __arg0 = ReferenceEquals(p_track_description, null) ? global::System.IntPtr.Zero : p_track_description.NativeReference;
        //    __Internal.LibvlcTrackDescriptionListRelease(__arg0);
        //}

        ///// <summary>Toggle fullscreen status on non-embedded video outputs.</summary>
        ///// <param name="p_mi">the media player</param>
        ///// <remarks>
        ///// <para>The same limitations applies to this function</para>
        ///// <para>as to libvlc_set_fullscreen().</para>
        ///// </remarks>
        //public static void LibvlcToggleFullscreen(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    __Internal.LibvlcToggleFullscreen(__arg0);
        //}

        ///// <summary>Enable or disable fullscreen.</summary>
        ///// <param name="p_mi">the media player</param>
        ///// <param name="b_fullscreen">boolean for fullscreen status</param>
        ///// <remarks>
        ///// <para>With most window managers, only a top-level windows can be in</para>
        ///// <para>full-screen mode. Hence, this function will not operate properly if</para>
        ///// <para>libvlc_media_player_set_xwindow() was used to embed the video in a</para>
        ///// <para>non-top-level window. In that case, the embedding window must be reparented</para>
        ///// <para>to the root windowbeforefullscreen mode is enabled. You will want</para>
        ///// <para>to reparent it back to its normal parent when disabling fullscreen.</para>
        ///// </remarks>
        //public static void LibvlcSetFullscreen(global::VideoLAN.LibVLC.MediaPlayer p_mi, int b_fullscreen)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    __Internal.LibvlcSetFullscreen(__arg0, b_fullscreen);
        //}

        ///// <summary>Get current fullscreen status.</summary>
        ///// <param name="p_mi">the media player</param>
        ///// <returns>the fullscreen status (boolean)</returns>
        //public static int LibvlcGetFullscreen(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcGetFullscreen(__arg0);
        //    return __ret;
        //}

        ///// <summary>
        ///// <para>Enable or disable key press events handling, according to the LibVLC hotkeys</para>
        ///// <para>configuration. By default and for historical reasons, keyboard events are</para>
        ///// <para>handled by the LibVLC video widget.</para>
        ///// </summary>
        ///// <param name="p_mi">the media player</param>
        ///// <param name="on">true to handle key press events, false to ignore them.</param>
        ///// <remarks>
        ///// <para>On X11, there can be only one subscriber for key press and mouse</para>
        ///// <para>click events per window. If your application has subscribed to those events</para>
        ///// <para>for the X window ID of the video widget, then LibVLC will not be able to</para>
        ///// <para>handle key presses and mouse clicks in any case.</para>
        ///// <para>This function is only implemented for X11 and Win32 at the moment.</para>
        ///// </remarks>
        //public static void LibvlcVideoSetKeyInput(global::VideoLAN.LibVLC.MediaPlayer p_mi, uint on)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    __Internal.LibvlcVideoSetKeyInput(__arg0, on);
        //}

        ///// <summary>
        ///// <para>Enable or disable mouse click events handling. By default, those events are</para>
        ///// <para>handled. This is needed for DVD menus to work, as well as a few video</para>
        ///// <para>filters such as &quot;puzzle&quot;.</para>
        ///// </summary>
        ///// <param name="p_mi">the media player</param>
        ///// <param name="on">true to handle mouse click events, false to ignore them.</param>
        ///// <remarks>
        ///// <para>libvlc_video_set_key_input().</para>
        ///// <para>This function is only implemented for X11 and Win32 at the moment.</para>
        ///// </remarks>
        //public static void LibvlcVideoSetMouseInput(global::VideoLAN.LibVLC.MediaPlayer p_mi, uint on)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    __Internal.LibvlcVideoSetMouseInput(__arg0, on);
        //}

        ///// <summary>Get the pixel dimensions of a video.</summary>
        ///// <param name="p_mi">media player</param>
        ///// <param name="num">number of the video (starting from, and most commonly 0)</param>
        ///// <param name="px">pointer to get the pixel width [OUT]</param>
        ///// <param name="py">pointer to get the pixel height [OUT]</param>
        ///// <returns>0 on success, -1 if the specified video does not exist</returns>
        //public static int LibvlcVideoGetSize(global::VideoLAN.LibVLC.MediaPlayer p_mi, uint num, ref uint px, ref uint py)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    fixed (uint* __refParamPtr2 = &px)
        //    {
        //        var __arg2 = __refParamPtr2;
        //        fixed (uint* __refParamPtr3 = &py)
        //        {
        //            var __arg3 = __refParamPtr3;
        //            var __ret = __Internal.LibvlcVideoGetSize(__arg0, num, __arg2, __arg3);
        //            return __ret;
        //        }
        //    }
        //}

        ///// <summary>
        ///// <para>Get the mouse pointer coordinates over a video.</para>
        ///// <para>Coordinates are expressed in terms of the decoded video resolution,</para>
        ///// <para>notin terms of pixels on the screen/viewport (to get the latter,</para>
        ///// <para>you can query your windowing system directly).</para>
        ///// </summary>
        ///// <param name="p_mi">media player</param>
        ///// <param name="num">number of the video (starting from, and most commonly 0)</param>
        ///// <param name="px">pointer to get the abscissa [OUT]</param>
        ///// <param name="py">pointer to get the ordinate [OUT]</param>
        ///// <returns>0 on success, -1 if the specified video does not exist</returns>
        ///// <remarks>
        ///// <para>Either of the coordinates may be negative or larger than the corresponding</para>
        ///// <para>dimension of the video, if the cursor is outside the rendering area.</para>
        ///// <para>The coordinates may be out-of-date if the pointer is not located</para>
        ///// <para>on the video rendering area. LibVLC does not track the pointer if it is</para>
        ///// <para>outside of the video widget.</para>
        ///// <para>LibVLC does not support multiple pointers (it does of course support</para>
        ///// <para>multiple input devices sharing the same pointer) at the moment.</para>
        ///// </remarks>
        //public static int LibvlcVideoGetCursor(global::VideoLAN.LibVLC.MediaPlayer p_mi, uint num, ref int px, ref int py)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    fixed (int* __refParamPtr2 = &px)
        //    {
        //        var __arg2 = __refParamPtr2;
        //        fixed (int* __refParamPtr3 = &py)
        //        {
        //            var __arg3 = __refParamPtr3;
        //            var __ret = __Internal.LibvlcVideoGetCursor(__arg0, num, __arg2, __arg3);
        //            return __ret;
        //        }
        //    }
        //}

        ///// <summary>
        ///// <para>Get the current video scaling factor.</para>
        ///// <para>See also libvlc_video_set_scale().</para>
        ///// </summary>
        ///// <param name="p_mi">the media player</param>
        ///// <returns>
        ///// <para>the currently configured zoom factor, or 0. if the video is set</para>
        ///// <para>to fit to the output window/drawable automatically.</para>
        ///// </returns>
        //public static float LibvlcVideoGetScale(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcVideoGetScale(__arg0);
        //    return __ret;
        //}

        ///// <summary>
        ///// <para>Set the video scaling factor. That is the ratio of the number of pixels on</para>
        ///// <para>screen to the number of pixels in the original decoded video in each</para>
        ///// <para>dimension. Zero is a special value; it will adjust the video to the output</para>
        ///// <para>window/drawable (in windowed mode) or the entire screen.</para>
        ///// </summary>
        ///// <param name="p_mi">the media player</param>
        ///// <param name="f_factor">the scaling factor, or zero</param>
        ///// <remarks>Note that not all video outputs support scaling.</remarks>
        //public static void LibvlcVideoSetScale(global::VideoLAN.LibVLC.MediaPlayer p_mi, float f_factor)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    __Internal.LibvlcVideoSetScale(__arg0, f_factor);
        //}

        ///// <summary>Get current video aspect ratio.</summary>
        ///// <param name="p_mi">the media player</param>
        ///// <returns>
        ///// <para>the video aspect ratio or NULL if unspecified</para>
        ///// <para>(the result must be released with free() or libvlc_free()).</para>
        ///// </returns>
        //public static sbyte* LibvlcVideoGetAspectRatio(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcVideoGetAspectRatio(__arg0);
        //    return __ret;
        //}

        /// <summary>Set new video aspect ratio.</summary>
        /// <param name="p_mi">the media player</param>
        /// <param name="psz_aspect">new video aspect-ratio or NULL to reset to default</param>
        /// <remarks>Invalid aspect ratios are ignored.</remarks>
        //public static void LibvlcVideoSetAspectRatio(global::VideoLAN.LibVLC.MediaPlayer p_mi, string psz_aspect)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    __Internal.LibvlcVideoSetAspectRatio(__arg0, psz_aspect);
        //}

        ///// <summary>Create a video viewpoint structure.</summary>
        ///// <returns>
        ///// <para>video viewpoint or NULL</para>
        ///// <para>(the result must be released with free() or libvlc_free()).</para>
        ///// </returns>
        ///// <remarks>LibVLC 3.0.0 and later</remarks>
        ////public static global::VideoLAN.LibVLC.VideoViewpoint LibvlcVideoNewViewpoint()
        ////{
        ////    var __ret = __Internal.LibvlcVideoNewViewpoint();
        ////    global::VideoLAN.LibVLC.VideoViewpoint __result0;
        ////    if (__ret == IntPtr.Zero) __result0 = null;
        ////    else if (global::VideoLAN.LibVLC.VideoViewpoint.NativeToManagedMap.ContainsKey(__ret))
        ////        __result0 = (global::VideoLAN.LibVLC.VideoViewpoint) global::VideoLAN.LibVLC.VideoViewpoint.NativeToManagedMap[__ret];
        ////    else __result0 = global::VideoLAN.LibVLC.VideoViewpoint.__CreateInstance(__ret);
        ////    return __result0;
        ////}

        ///// <summary>Update the video viewpoint information.</summary>
        ///// <param name="p_mi">the media player</param>
        ///// <param name="p_viewpoint">video viewpoint allocated via libvlc_video_new_viewpoint()</param>
        ///// <param name="b_absolute">
        ///// <para>if true replace the old viewpoint with the new one. If</para>
        ///// <para>false, increase/decrease it.</para>
        ///// </param>
        ///// <returns>-1 in case of error, 0 otherwise</returns>
        ///// <remarks>
        ///// <para>It is safe to call this function before the media player is started.</para>
        ///// <para>LibVLC 3.0.0 and later</para>
        ///// <para>the values are set asynchronously, it will be used by the next frame displayed.</para>
        ///// </remarks>
        ////public static int LibvlcVideoUpdateViewpoint(global::VideoLAN.LibVLC.MediaPlayer p_mi, global::VideoLAN.LibVLC.VideoViewpoint p_viewpoint, bool b_absolute)
        ////{
        ////    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        ////    var __arg1 = ReferenceEquals(p_viewpoint, null) ? global::System.IntPtr.Zero : p_viewpoint.NativeReference;
        ////    var __ret = __Internal.LibvlcVideoUpdateViewpoint(__arg0, __arg1, b_absolute);
        ////    return __ret;
        ////}

        ///// <summary>Get current video subtitle.</summary>
        ///// <param name="p_mi">the media player</param>
        ///// <returns>the video subtitle selected, or -1 if none</returns>
        //public static int LibvlcVideoGetSpu(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcVideoGetSpu(__arg0);
        //    return __ret;
        //}

        ///// <summary>Get the number of available video subtitles.</summary>
        ///// <param name="p_mi">the media player</param>
        ///// <returns>the number of available video subtitles</returns>
        //public static int LibvlcVideoGetSpuCount(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcVideoGetSpuCount(__arg0);
        //    return __ret;
        //}

        ///// <summary>Get the description of available video subtitles.</summary>
        ///// <param name="p_mi">the media player</param>
        ///// <returns>
        ///// <para>list containing description of available video subtitles.</para>
        ///// <para>It must be freed with libvlc_track_description_list_release()</para>
        ///// </returns>
        //public static global::VideoLAN.LibVLC.TrackDescription LibvlcVideoGetSpuDescription(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcVideoGetSpuDescription(__arg0);
        //    global::VideoLAN.LibVLC.TrackDescription __result0;
        //    if (__ret == IntPtr.Zero) __result0 = null;
        //    else if (global::VideoLAN.LibVLC.TrackDescription.NativeToManagedMap.ContainsKey(__ret))
        //        __result0 = (global::VideoLAN.LibVLC.TrackDescription) global::VideoLAN.LibVLC.TrackDescription.NativeToManagedMap[__ret];
        //    else __result0 = global::VideoLAN.LibVLC.TrackDescription.__CreateInstance(__ret);
        //    return __result0;
        //}

        ///// <summary>Set new video subtitle.</summary>
        ///// <param name="p_mi">the media player</param>
        ///// <param name="i_spu">video subtitle track to select (i_id from track description)</param>
        ///// <returns>0 on success, -1 if out of range</returns>
        //public static int LibvlcVideoSetSpu(global::VideoLAN.LibVLC.MediaPlayer p_mi, int i_spu)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcVideoSetSpu(__arg0, i_spu);
        //    return __ret;
        //}

        ///// <summary>
        ///// <para>Get the current subtitle delay. Positive values means subtitles are being</para>
        ///// <para>displayed later, negative values earlier.</para>
        ///// </summary>
        ///// <param name="p_mi">media player</param>
        ///// <returns>time (in microseconds) the display of subtitles is being delayed</returns>
        ///// <remarks>LibVLC 2.0.0 or later</remarks>
        //public static long LibvlcVideoGetSpuDelay(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcVideoGetSpuDelay(__arg0);
        //    return __ret;
        //}

        ///// <summary>
        ///// <para>Set the subtitle delay. This affects the timing of when the subtitle will</para>
        ///// <para>be displayed. Positive values result in subtitles being displayed later,</para>
        ///// <para>while negative values will result in subtitles being displayed earlier.</para>
        ///// </summary>
        ///// <param name="p_mi">media player</param>
        ///// <param name="i_delay">time (in microseconds) the display of subtitles should be delayed</param>
        ///// <returns>0 on success, -1 on error</returns>
        ///// <remarks>
        ///// <para>The subtitle delay will be reset to zero each time the media changes.</para>
        ///// <para>LibVLC 2.0.0 or later</para>
        ///// </remarks>
        //public static int LibvlcVideoSetSpuDelay(global::VideoLAN.LibVLC.MediaPlayer p_mi, long i_delay)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcVideoSetSpuDelay(__arg0, i_delay);
        //    return __ret;
        //}

        ///// <summary>Get the full description of available titles</summary>
        ///// <param name="p_mi">the media player</param>
        ///// <param name="titles">
        ///// <para>address to store an allocated array of title descriptions</para>
        ///// <para>descriptions (must be freed with libvlc_title_descriptions_release()</para>
        ///// <para>by the caller) [OUT]</para>
        ///// </param>
        ///// <returns>the number of titles (-1 on error)</returns>
        ///// <remarks>LibVLC 3.0.0 and later.</remarks>
        //public static int LibvlcMediaPlayerGetFullTitleDescriptions(global::VideoLAN.LibVLC.MediaPlayer p_mi, global::VideoLAN.LibVLC.TitleDescription titles)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __arg1 = ReferenceEquals(titles, null) ? global::System.IntPtr.Zero : titles.NativeReference;
        //    var __ret = __Internal.LibvlcMediaPlayerGetFullTitleDescriptions(__arg0, __arg1);
        //    return __ret;
        //}

        ///// <summary>Release a title description</summary>
        ///// <param name="p_titles">title description array to release</param>
        ///// <param name="i_count">number of title descriptions to release</param>
        ///// <remarks>LibVLC 3.0.0 and later</remarks>
        //public static void LibvlcTitleDescriptionsRelease(global::VideoLAN.LibVLC.TitleDescription p_titles, uint i_count)
        //{
        //    var __arg0 = ReferenceEquals(p_titles, null) ? global::System.IntPtr.Zero : p_titles.NativeReference;
        //    __Internal.LibvlcTitleDescriptionsRelease(__arg0, i_count);
        //}

        ///// <summary>Get the full description of available chapters</summary>
        ///// <param name="p_mi">the media player</param>
        ///// <param name="i_chapters_of_title">index of the title to query for chapters (uses current title if set to -1)</param>
        ///// <param name="pp_chapters">
        ///// <para>address to store an allocated array of chapter descriptions</para>
        ///// <para>descriptions (must be freed with libvlc_chapter_descriptions_release()</para>
        ///// <para>by the caller) [OUT]</para>
        ///// </param>
        ///// <returns>the number of chapters (-1 on error)</returns>
        ///// <remarks>LibVLC 3.0.0 and later.</remarks>
        //public static int LibvlcMediaPlayerGetFullChapterDescriptions(global::VideoLAN.LibVLC.MediaPlayer p_mi, int i_chapters_of_title, global::VideoLAN.LibVLC.ChapterDescription pp_chapters)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __arg2 = ReferenceEquals(pp_chapters, null) ? global::System.IntPtr.Zero : pp_chapters.NativeReference;
        //    var __ret = __Internal.LibvlcMediaPlayerGetFullChapterDescriptions(__arg0, i_chapters_of_title, __arg2);
        //    return __ret;
        //}

        ///// <summary>Release a chapter description</summary>
        ///// <param name="p_chapters">chapter description array to release</param>
        ///// <param name="i_count">number of chapter descriptions to release</param>
        ///// <remarks>LibVLC 3.0.0 and later</remarks>
        //public static void LibvlcChapterDescriptionsRelease(global::VideoLAN.LibVLC.ChapterDescription p_chapters, uint i_count)
        //{
        //    var __arg0 = ReferenceEquals(p_chapters, null) ? global::System.IntPtr.Zero : p_chapters.NativeReference;
        //    __Internal.LibvlcChapterDescriptionsRelease(__arg0, i_count);
        //}

        ///// <summary>Get current crop filter geometry.</summary>
        ///// <param name="p_mi">the media player</param>
        ///// <returns>the crop filter geometry or NULL if unset</returns>
        //public static sbyte* LibvlcVideoGetCropGeometry(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcVideoGetCropGeometry(__arg0);
        //    return __ret;
        //}

        ///// <summary>Set new crop filter geometry.</summary>
        ///// <param name="p_mi">the media player</param>
        ///// <param name="psz_geometry">new crop filter geometry (NULL to unset)</param>
        //public static void LibvlcVideoSetCropGeometry(global::VideoLAN.LibVLC.MediaPlayer p_mi, string psz_geometry)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    __Internal.LibvlcVideoSetCropGeometry(__arg0, psz_geometry);
        //}

        ///// <summary>Get current teletext page requested or 0 if it's disabled.</summary>
        ///// <param name="p_mi">the media player</param>
        ///// <returns>the current teletext page requested.</returns>
        ///// <remarks>
        ///// <para>Teletext is disabled by default, call libvlc_video_set_teletext() to enable</para>
        ///// <para>it.</para>
        ///// </remarks>
        //public static int LibvlcVideoGetTeletext(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcVideoGetTeletext(__arg0);
        //    return __ret;
        //}

        ///// <summary>Set new teletext page to retrieve.</summary>
        ///// <param name="p_mi">the media player</param>
        ///// <param name="i_page">
        ///// <para>teletex page number requested. This value can be 0 to disable</para>
        ///// <para>teletext, a number in the range ]0;1000[ to show the requested page, or a</para>
        ///// </param>
        ///// <remarks>This function can also be used to send a teletext key.</remarks>
        //public static void LibvlcVideoSetTeletext(global::VideoLAN.LibVLC.MediaPlayer p_mi, int i_page)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    __Internal.LibvlcVideoSetTeletext(__arg0, i_page);
        //}

        ///// <summary>Get number of available video tracks.</summary>
        ///// <param name="p_mi">media player</param>
        ///// <returns>the number of available video tracks (int)</returns>
        //public static int LibvlcVideoGetTrackCount(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcVideoGetTrackCount(__arg0);
        //    return __ret;
        //}

        ///// <summary>Get the description of available video tracks.</summary>
        ///// <param name="p_mi">media player</param>
        ///// <returns>
        ///// <para>list with description of available video tracks, or NULL on error.</para>
        ///// <para>It must be freed with libvlc_track_description_list_release()</para>
        ///// </returns>
        //public static global::VideoLAN.LibVLC.TrackDescription LibvlcVideoGetTrackDescription(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcVideoGetTrackDescription(__arg0);
        //    global::VideoLAN.LibVLC.TrackDescription __result0;
        //    if (__ret == IntPtr.Zero) __result0 = null;
        //    else if (global::VideoLAN.LibVLC.TrackDescription.NativeToManagedMap.ContainsKey(__ret))
        //        __result0 = (global::VideoLAN.LibVLC.TrackDescription) global::VideoLAN.LibVLC.TrackDescription.NativeToManagedMap[__ret];
        //    else __result0 = global::VideoLAN.LibVLC.TrackDescription.__CreateInstance(__ret);
        //    return __result0;
        //}

        ///// <summary>Get current video track.</summary>
        ///// <param name="p_mi">media player</param>
        ///// <returns>the video track ID (int) or -1 if no active input</returns>
        //public static int LibvlcVideoGetTrack(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcVideoGetTrack(__arg0);
        //    return __ret;
        //}

        ///// <summary>Set video track.</summary>
        ///// <param name="p_mi">media player</param>
        ///// <param name="i_track">the track ID (i_id field from track description)</param>
        ///// <returns>0 on success, -1 if out of range</returns>
        //public static int LibvlcVideoSetTrack(global::VideoLAN.LibVLC.MediaPlayer p_mi, int i_track)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcVideoSetTrack(__arg0, i_track);
        //    return __ret;
        //}

        ///// <summary>Take a snapshot of the current video window.</summary>
        ///// <param name="p_mi">media player instance</param>
        ///// <param name="num">number of video output (typically 0 for the first/only one)</param>
        ///// <param name="psz_filepath">the path where to save the screenshot to</param>
        ///// <param name="i_width">the snapshot's width</param>
        ///// <param name="i_height">the snapshot's height</param>
        ///// <returns>0 on success, -1 if the video was not found</returns>
        ///// <remarks>
        ///// <para>If i_width AND i_height is 0, original size is used.</para>
        ///// <para>If i_width XOR i_height is 0, original aspect-ratio is preserved.</para>
        ///// </remarks>
        //public static int LibvlcVideoTakeSnapshot(global::VideoLAN.LibVLC.MediaPlayer p_mi, uint num, string psz_filepath, uint i_width, uint i_height)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcVideoTakeSnapshot(__arg0, num, psz_filepath, i_width, i_height);
        //    return __ret;
        //}

        ///// <summary>Enable or disable deinterlace filter</summary>
        ///// <param name="p_mi">libvlc media player</param>
        ///// <param name="psz_mode">type of deinterlace filter, NULL to disable</param>
        //public static void LibvlcVideoSetDeinterlace(global::VideoLAN.LibVLC.MediaPlayer p_mi, string psz_mode)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    __Internal.LibvlcVideoSetDeinterlace(__arg0, psz_mode);
        //}

        ///// <summary>Get an integer marquee option value</summary>
        ///// <param name="p_mi">libvlc media player</param>
        ///// <param name="option">marq option to get</param>
        ///// <remarks>libvlc_video_marquee_int_option_t</remarks>
        //public static int LibvlcVideoGetMarqueeInt(global::VideoLAN.LibVLC.MediaPlayer p_mi, uint option)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcVideoGetMarqueeInt(__arg0, option);
        //    return __ret;
        //}

        ///// <summary>Get a string marquee option value</summary>
        ///// <param name="p_mi">libvlc media player</param>
        ///// <param name="option">marq option to get</param>
        ///// <remarks>libvlc_video_marquee_string_option_t</remarks>
        //public static sbyte* LibvlcVideoGetMarqueeString(global::VideoLAN.LibVLC.MediaPlayer p_mi, uint option)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcVideoGetMarqueeString(__arg0, option);
        //    return __ret;
        //}

        ///// <summary>Enable, disable or set an integer marquee option</summary>
        ///// <param name="p_mi">libvlc media player</param>
        ///// <param name="option">marq option to set</param>
        ///// <param name="i_val">marq option value</param>
        ///// <remarks>
        ///// <para>Setting libvlc_marquee_Enable has the side effect of enabling (arg !0)</para>
        ///// <para>or disabling (arg 0) the marq filter.</para>
        ///// <para>libvlc_video_marquee_int_option_t</para>
        ///// </remarks>
        //public static void LibvlcVideoSetMarqueeInt(global::VideoLAN.LibVLC.MediaPlayer p_mi, uint option, int i_val)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    __Internal.LibvlcVideoSetMarqueeInt(__arg0, option, i_val);
        //}

        ///// <summary>Set a marquee string option</summary>
        ///// <param name="p_mi">libvlc media player</param>
        ///// <param name="option">marq option to set</param>
        ///// <param name="psz_text">marq option value</param>
        ///// <remarks>libvlc_video_marquee_string_option_t</remarks>
        //public static void LibvlcVideoSetMarqueeString(global::VideoLAN.LibVLC.MediaPlayer p_mi, uint option, string psz_text)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    __Internal.LibvlcVideoSetMarqueeString(__arg0, option, psz_text);
        //}

        ///// <summary>Get integer logo option.</summary>
        ///// <param name="p_mi">libvlc media player instance</param>
        ///// <param name="option">logo option to get, values of libvlc_video_logo_option_t</param>
        //public static int LibvlcVideoGetLogoInt(global::VideoLAN.LibVLC.MediaPlayer p_mi, uint option)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcVideoGetLogoInt(__arg0, option);
        //    return __ret;
        //}

        ///// <summary>
        ///// <para>Set logo option as integer. Options that take a different type value</para>
        ///// <para>are ignored.</para>
        ///// <para>Passing libvlc_logo_enable as option value has the side effect of</para>
        ///// <para>starting (arg !0) or stopping (arg 0) the logo filter.</para>
        ///// </summary>
        ///// <param name="p_mi">libvlc media player instance</param>
        ///// <param name="option">logo option to set, values of libvlc_video_logo_option_t</param>
        ///// <param name="value">logo option value</param>
        //public static void LibvlcVideoSetLogoInt(global::VideoLAN.LibVLC.MediaPlayer p_mi, uint option, int value)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    __Internal.LibvlcVideoSetLogoInt(__arg0, option, value);
        //}

        ///// <summary>
        ///// <para>Set logo option as string. Options that take a different type value</para>
        ///// <para>are ignored.</para>
        ///// </summary>
        ///// <param name="p_mi">libvlc media player instance</param>
        ///// <param name="option">logo option to set, values of libvlc_video_logo_option_t</param>
        ///// <param name="psz_value">logo option value</param>
        //public static void LibvlcVideoSetLogoString(global::VideoLAN.LibVLC.MediaPlayer p_mi, uint option, string psz_value)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    __Internal.LibvlcVideoSetLogoString(__arg0, option, psz_value);
        //}

        ///// <summary>Get integer adjust option.</summary>
        ///// <param name="p_mi">libvlc media player instance</param>
        ///// <param name="option">adjust option to get, values of libvlc_video_adjust_option_t</param>
        ///// <remarks>LibVLC 1.1.1 and later.</remarks>
        //public static int LibvlcVideoGetAdjustInt(global::VideoLAN.LibVLC.MediaPlayer p_mi, uint option)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcVideoGetAdjustInt(__arg0, option);
        //    return __ret;
        //}

        ///// <summary>
        ///// <para>Set adjust option as integer. Options that take a different type value</para>
        ///// <para>are ignored.</para>
        ///// <para>Passing libvlc_adjust_enable as option value has the side effect of</para>
        ///// <para>starting (arg !0) or stopping (arg 0) the adjust filter.</para>
        ///// </summary>
        ///// <param name="p_mi">libvlc media player instance</param>
        ///// <param name="option">adust option to set, values of libvlc_video_adjust_option_t</param>
        ///// <param name="value">adjust option value</param>
        ///// <remarks>LibVLC 1.1.1 and later.</remarks>
        //public static void LibvlcVideoSetAdjustInt(global::VideoLAN.LibVLC.MediaPlayer p_mi, uint option, int value)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    __Internal.LibvlcVideoSetAdjustInt(__arg0, option, value);
        //}

        ///// <summary>Get float adjust option.</summary>
        ///// <param name="p_mi">libvlc media player instance</param>
        ///// <param name="option">adjust option to get, values of libvlc_video_adjust_option_t</param>
        ///// <remarks>LibVLC 1.1.1 and later.</remarks>
        //public static float LibvlcVideoGetAdjustFloat(global::VideoLAN.LibVLC.MediaPlayer p_mi, uint option)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcVideoGetAdjustFloat(__arg0, option);
        //    return __ret;
        //}

        ///// <summary>
        ///// <para>Set adjust option as float. Options that take a different type value</para>
        ///// <para>are ignored.</para>
        ///// </summary>
        ///// <param name="p_mi">libvlc media player instance</param>
        ///// <param name="option">adust option to set, values of libvlc_video_adjust_option_t</param>
        ///// <param name="value">adjust option value</param>
        ///// <remarks>LibVLC 1.1.1 and later.</remarks>
        //public static void LibvlcVideoSetAdjustFloat(global::VideoLAN.LibVLC.MediaPlayer p_mi, uint option, float value)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    __Internal.LibvlcVideoSetAdjustFloat(__arg0, option, value);
        //}

        ///// <summary>Gets the list of available audio output modules.</summary>
        ///// <param name="p_instance">libvlc instance</param>
        ///// <returns>list of available audio outputs. It must be freed with</returns>
        ///// <remarks>
        ///// <para>libvlc_audio_output_list_release</para>
        ///// <para>libvlc_audio_output_t .</para>
        ///// <para>In case of error, NULL is returned.</para>
        ///// </remarks>
        //public static global::VideoLAN.LibVLC.AudioOutputDescription LibvlcAudioOutputListGet(global::VideoLAN.LibVLC.Manual.Instance p_instance)
        //{
        //    var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.NativeReference;
        //    var __ret = __Internal.LibvlcAudioOutputListGet(__arg0);
        //    global::VideoLAN.LibVLC.AudioOutputDescription __result0;
        //    if (__ret == IntPtr.Zero) __result0 = null;
        //    else if (global::VideoLAN.LibVLC.AudioOutputDescription.NativeToManagedMap.ContainsKey(__ret))
        //        __result0 = (global::VideoLAN.LibVLC.AudioOutputDescription) global::VideoLAN.LibVLC.AudioOutputDescription.NativeToManagedMap[__ret];
        //    else __result0 = global::VideoLAN.LibVLC.AudioOutputDescription.__CreateInstance(__ret);
        //    return __result0;
        //}

    
        ///// <summary>Selects an audio output module.</summary>
        ///// <param name="p_mi">media player</param>
        ///// <param name="psz_name">
        ///// <para>name of audio output,</para>
        ///// <para>use psz_name of</para>
        ///// </param>
        ///// <returns>0 if function succeeded, -1 on error</returns>
        ///// <remarks>
        ///// <para>Any change will take be effect only after playback is stopped and</para>
        ///// <para>restarted. Audio output cannot be changed while playing.</para>
        ///// <para>libvlc_audio_output_t</para>
        ///// </remarks>
        //public static int LibvlcAudioOutputSet(global::VideoLAN.LibVLC.MediaPlayer p_mi, string psz_name)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcAudioOutputSet(__arg0, psz_name);
        //    return __ret;
        //}

        /// <summary>Gets a list of potential audio output devices,</summary>
        /// <param name="mp">media player</param>
        /// <returns>
        /// <para>A NULL-terminated linked list of potential audio output devices.</para>
        /// <para>It must be freed with libvlc_audio_output_device_list_release()</para>
        /// </returns>
        /// <remarks>
        /// <para>libvlc_audio_output_device_set().</para>
        /// <para>Not all audio outputs support enumerating devices.</para>
        /// <para>The audio output may be functional even if the list is empty (NULL).</para>
        /// <para>The list may not be exhaustive.</para>
        /// <para>Some audio output devices in the list might not actually work in</para>
        /// <para>some circumstances. By default, it is recommended to not specify any</para>
        /// <para>explicit audio device.</para>
        /// <para>LibVLC 2.2.0 or later.</para>
        /// </remarks>
        //public static global::VideoLAN.LibVLC.AudioOutputDevice LibvlcAudioOutputDeviceEnum(global::VideoLAN.LibVLC.MediaPlayer mp)
        //{
        //    var __arg0 = ReferenceEquals(mp, null) ? global::System.IntPtr.Zero : mp.NativeReference;
        //    var __ret = __Internal.LibvlcAudioOutputDeviceEnum(__arg0);
        //    global::VideoLAN.LibVLC.AudioOutputDevice __result0;
        //    if (__ret == IntPtr.Zero) __result0 = null;
        //    else if (global::VideoLAN.LibVLC.AudioOutputDevice.NativeToManagedMap.ContainsKey(__ret))
        //        __result0 = (global::VideoLAN.LibVLC.AudioOutputDevice) global::VideoLAN.LibVLC.AudioOutputDevice.NativeToManagedMap[__ret];
        //    else __result0 = global::VideoLAN.LibVLC.AudioOutputDevice.__CreateInstance(__ret);
        //    return __result0;
        //}
        
        ///// <summary>Configures an explicit audio output device.</summary>
        ///// <param name="mp">media player</param>
        ///// <param name="module">
        ///// <para>If NULL, current audio output module.</para>
        ///// <para>if non-NULL, name of audio output module</para>
        ///// <para>(</para>
        ///// </param>
        ///// <param name="device_id">device identifier string</param>
        ///// <returns>Nothing. Errors are ignored (this is a design bug).</returns>
        ///// <remarks>
        ///// <para>If the module paramater is NULL, audio output will be moved to the device</para>
        ///// <para>specified by the device identifier string immediately. This is the</para>
        ///// <para>recommended usage.</para>
        ///// <para>A list of adequate potential device strings can be obtained with</para>
        ///// <para>libvlc_audio_output_device_enum().</para>
        ///// <para>However passing NULL is supported in LibVLC version 2.2.0 and later only;</para>
        ///// <para>in earlier versions, this function would have no effects when the module</para>
        ///// <para>parameter was NULL.</para>
        ///// <para>If the module parameter is not NULL, the device parameter of the</para>
        ///// <para>corresponding audio output, if it exists, will be set to the specified</para>
        ///// <para>string. Note that some audio output modules do not have such a parameter</para>
        ///// <para>(notably MMDevice and PulseAudio).</para>
        ///// <para>A list of adequate potential device strings can be obtained with</para>
        ///// <para>libvlc_audio_output_device_list_get().</para>
        ///// <para>This function does not select the specified audio output plugin.</para>
        ///// <para>libvlc_audio_output_set() is used for that purpose.</para>
        ///// <para>The syntax for the device parameter depends on the audio output.</para>
        ///// <para>Some audio output modules require further parameters (e.g. a channels map</para>
        ///// <para>in the case of ALSA).</para>
        ///// <para>libvlc_audio_output_t)</para>
        ///// </remarks>
        //public static void LibvlcAudioOutputDeviceSet(global::VideoLAN.LibVLC.MediaPlayer mp, string module, string device_id)
        //{
        //    var __arg0 = ReferenceEquals(mp, null) ? global::System.IntPtr.Zero : mp.NativeReference;
        //    __Internal.LibvlcAudioOutputDeviceSet(__arg0, module, device_id);
        //}

        ///// <summary>Get the current audio output device identifier.</summary>
        ///// <param name="mp">media player</param>
        ///// <returns>
        ///// <para>the current audio output device identifier</para>
        ///// <para>NULL if no device is selected or in case of error</para>
        ///// <para>(the result must be released with free() or libvlc_free()).</para>
        ///// </returns>
        ///// <remarks>
        ///// <para>This complements libvlc_audio_output_device_set().</para>
        ///// <para>The initial value for the current audio output device identifier</para>
        ///// <para>may not be set or may be some unknown value. A LibVLC application should</para>
        ///// <para>compare this value against the known device identifiers (e.g. those that</para>
        ///// <para>were previously retrieved by a call to libvlc_audio_output_device_enum or</para>
        ///// <para>libvlc_audio_output_device_list_get) to find the current audio output device.</para>
        ///// <para>It is possible that the selected audio output device changes (an external</para>
        ///// <para>change) without a call to libvlc_audio_output_device_set. That may make this</para>
        ///// <para>method unsuitable to use if a LibVLC application is attempting to track</para>
        ///// <para>dynamic audio device changes as they happen.</para>
        ///// <para>LibVLC 3.0.0 or later.</para>
        ///// </remarks>
        //public static sbyte* LibvlcAudioOutputDeviceGet(global::VideoLAN.LibVLC.MediaPlayer mp)
        //{
        //    var __arg0 = ReferenceEquals(mp, null) ? global::System.IntPtr.Zero : mp.NativeReference;
        //    var __ret = __Internal.LibvlcAudioOutputDeviceGet(__arg0);
        //    return __ret;
        //}

        ///// <summary>Toggle mute status.</summary>
        ///// <param name="p_mi">media player</param>
        ///// <remarks>
        ///// <para>Toggling mute atomically is not always possible: On some platforms,</para>
        ///// <para>other processes can mute the VLC audio playback stream asynchronously. Thus,</para>
        ///// <para>there is a small race condition where toggling will not work.</para>
        ///// <para>See also the limitations of libvlc_audio_set_mute().</para>
        ///// </remarks>
        //public static void LibvlcAudioToggleMute(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    __Internal.LibvlcAudioToggleMute(__arg0);
        //}

        ///// <summary>Get current mute status.</summary>
        ///// <param name="p_mi">media player</param>
        ///// <returns>the mute status (boolean) if defined, -1 if undefined/unapplicable</returns>
        //public static int LibvlcAudioGetMute(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcAudioGetMute(__arg0);
        //    return __ret;
        //}

        ///// <summary>Set mute status.</summary>
        ///// <param name="p_mi">media player</param>
        ///// <param name="status">If status is true then mute, otherwise unmute</param>
        ///// <remarks>
        ///// <para>This function does not always work. If there are no active audio</para>
        ///// <para>playback stream, the mute status might not be available. If digital</para>
        ///// <para>pass-through (S/PDIF, HDMI...) is in use, muting may be unapplicable. Also</para>
        ///// <para>some audio output plugins do not support muting at all.</para>
        ///// <para>To force silent playback, disable all audio tracks. This is more</para>
        ///// <para>efficient and reliable than mute.</para>
        ///// </remarks>
        //public static void LibvlcAudioSetMute(global::VideoLAN.LibVLC.MediaPlayer p_mi, int status)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    __Internal.LibvlcAudioSetMute(__arg0, status);
        //}

        ///// <summary>Get current software audio volume.</summary>
        ///// <param name="p_mi">media player</param>
        ///// <returns>
        ///// <para>the software volume in percents</para>
        ///// <para>(0 = mute, 100 = nominal / 0dB)</para>
        ///// </returns>
        //public static int LibvlcAudioGetVolume(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcAudioGetVolume(__arg0);
        //    return __ret;
        //}

        ///// <summary>Set current software audio volume.</summary>
        ///// <param name="p_mi">media player</param>
        ///// <param name="i_volume">the volume in percents (0 = mute, 100 = 0dB)</param>
        ///// <returns>0 if the volume was set, -1 if it was out of range</returns>
        //public static int LibvlcAudioSetVolume(global::VideoLAN.LibVLC.MediaPlayer p_mi, int i_volume)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcAudioSetVolume(__arg0, i_volume);
        //    return __ret;
        //}

        ///// <summary>Get number of available audio tracks.</summary>
        ///// <param name="p_mi">media player</param>
        ///// <returns>the number of available audio tracks (int), or -1 if unavailable</returns>
        //public static int LibvlcAudioGetTrackCount(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcAudioGetTrackCount(__arg0);
        //    return __ret;
        //}

        ///// <summary>Get the description of available audio tracks.</summary>
        ///// <param name="p_mi">media player</param>
        ///// <returns>
        ///// <para>list with description of available audio tracks, or NULL.</para>
        ///// <para>It must be freed with libvlc_track_description_list_release()</para>
        ///// </returns>
        //public static global::VideoLAN.LibVLC.TrackDescription LibvlcAudioGetTrackDescription(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcAudioGetTrackDescription(__arg0);
        //    global::VideoLAN.LibVLC.TrackDescription __result0;
        //    if (__ret == IntPtr.Zero) __result0 = null;
        //    else if (global::VideoLAN.LibVLC.TrackDescription.NativeToManagedMap.ContainsKey(__ret))
        //        __result0 = (global::VideoLAN.LibVLC.TrackDescription) global::VideoLAN.LibVLC.TrackDescription.NativeToManagedMap[__ret];
        //    else __result0 = global::VideoLAN.LibVLC.TrackDescription.__CreateInstance(__ret);
        //    return __result0;
        //}

        ///// <summary>Get current audio track.</summary>
        ///// <param name="p_mi">media player</param>
        ///// <returns>the audio track ID or -1 if no active input.</returns>
        //public static int LibvlcAudioGetTrack(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcAudioGetTrack(__arg0);
        //    return __ret;
        //}

        ///// <summary>Set current audio track.</summary>
        ///// <param name="p_mi">media player</param>
        ///// <param name="i_track">the track ID (i_id field from track description)</param>
        ///// <returns>0 on success, -1 on error</returns>
        //public static int LibvlcAudioSetTrack(global::VideoLAN.LibVLC.MediaPlayer p_mi, int i_track)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcAudioSetTrack(__arg0, i_track);
        //    return __ret;
        //}

        ///// <summary>Get current audio channel.</summary>
        ///// <param name="p_mi">media player</param>
        ///// <returns>the audio channel</returns>
        ///// <remarks>libvlc_audio_output_channel_t</remarks>
        //public static int LibvlcAudioGetChannel(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcAudioGetChannel(__arg0);
        //    return __ret;
        //}

        ///// <summary>Set current audio channel.</summary>
        ///// <param name="p_mi">media player</param>
        ///// <param name="channel">the audio channel,</param>
        ///// <returns>0 on success, -1 on error</returns>
        ///// <remarks>libvlc_audio_output_channel_t</remarks>
        //public static int LibvlcAudioSetChannel(global::VideoLAN.LibVLC.MediaPlayer p_mi, int channel)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcAudioSetChannel(__arg0, channel);
        //    return __ret;
        //}

        ///// <summary>Get current audio delay.</summary>
        ///// <param name="p_mi">media player</param>
        ///// <returns>the audio delay (microseconds)</returns>
        ///// <remarks>LibVLC 1.1.1 or later</remarks>
        //public static long LibvlcAudioGetDelay(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcAudioGetDelay(__arg0);
        //    return __ret;
        //}

        ///// <summary>Set current audio delay. The audio delay will be reset to zero each time the media changes.</summary>
        ///// <param name="p_mi">media player</param>
        ///// <param name="i_delay">the audio delay (microseconds)</param>
        ///// <returns>0 on success, -1 on error</returns>
        ///// <remarks>LibVLC 1.1.1 or later</remarks>
        //public static int LibvlcAudioSetDelay(global::VideoLAN.LibVLC.MediaPlayer p_mi, long i_delay)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcAudioSetDelay(__arg0, i_delay);
        //    return __ret;
        //}

       
    }
}
