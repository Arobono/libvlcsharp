// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------

using System;
using System.Runtime.InteropServices;
using System.Security;

namespace VideoLAN.LibVLC
{
    /// <summary>This structure is opaque. It represents a libvlc log iterator</summary>
    public unsafe partial class LogIterator
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VideoLAN.LibVLC.LogIterator> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VideoLAN.LibVLC.LogIterator>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::VideoLAN.LibVLC.LogIterator __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::VideoLAN.LibVLC.LogIterator(native.ToPointer(), skipVTables);
        }

        internal static global::VideoLAN.LibVLC.LogIterator __CreateInstance(global::VideoLAN.LibVLC.LogIterator.__Internal native, bool skipVTables = false)
        {
            return new global::VideoLAN.LibVLC.LogIterator(native, skipVTables);
        }

        private static void* __CopyValue(global::VideoLAN.LibVLC.LogIterator.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::VideoLAN.LibVLC.LogIterator.__Internal));
            *(global::VideoLAN.LibVLC.LogIterator.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LogIterator(global::VideoLAN.LibVLC.LogIterator.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected LogIterator(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class LogMessage : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int i_severity;

            [FieldOffset(8)]
            internal global::System.IntPtr psz_type;

            [FieldOffset(16)]
            internal global::System.IntPtr psz_name;

            [FieldOffset(24)]
            internal global::System.IntPtr psz_header;

            [FieldOffset(32)]
            internal global::System.IntPtr psz_message;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0libvlc_log_message_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VideoLAN.LibVLC.LogMessage> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VideoLAN.LibVLC.LogMessage>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::VideoLAN.LibVLC.LogMessage __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::VideoLAN.LibVLC.LogMessage(native.ToPointer(), skipVTables);
        }

        internal static global::VideoLAN.LibVLC.LogMessage __CreateInstance(global::VideoLAN.LibVLC.LogMessage.__Internal native, bool skipVTables = false)
        {
            return new global::VideoLAN.LibVLC.LogMessage(native, skipVTables);
        }

        private static void* __CopyValue(global::VideoLAN.LibVLC.LogMessage.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::VideoLAN.LibVLC.LogMessage.__Internal));
            *(global::VideoLAN.LibVLC.LogMessage.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LogMessage(global::VideoLAN.LibVLC.LogMessage.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected LogMessage(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public LogMessage()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::VideoLAN.LibVLC.LogMessage.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public LogMessage(global::VideoLAN.LibVLC.LogMessage _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::VideoLAN.LibVLC.LogMessage.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::VideoLAN.LibVLC.LogMessage.__Internal*) __Instance) = *((global::VideoLAN.LibVLC.LogMessage.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::VideoLAN.LibVLC.LogMessage __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int ISeverity
        {
            get
            {
                return ((global::VideoLAN.LibVLC.LogMessage.__Internal*) __Instance)->i_severity;
            }

            set
            {
                ((global::VideoLAN.LibVLC.LogMessage.__Internal*) __Instance)->i_severity = value;
            }
        }

        public string PszType
        {
            get
            {
                return Marshal.PtrToStringAnsi(((global::VideoLAN.LibVLC.LogMessage.__Internal*) __Instance)->psz_type);
            }

            set
            {
                ((global::VideoLAN.LibVLC.LogMessage.__Internal*) __Instance)->psz_type = Marshal.StringToHGlobalAnsi(value);
            }
        }

        public string PszName
        {
            get
            {
                return Marshal.PtrToStringAnsi(((global::VideoLAN.LibVLC.LogMessage.__Internal*) __Instance)->psz_name);
            }

            set
            {
                ((global::VideoLAN.LibVLC.LogMessage.__Internal*) __Instance)->psz_name = Marshal.StringToHGlobalAnsi(value);
            }
        }

        public string PszHeader
        {
            get
            {
                return Marshal.PtrToStringAnsi(((global::VideoLAN.LibVLC.LogMessage.__Internal*) __Instance)->psz_header);
            }

            set
            {
                ((global::VideoLAN.LibVLC.LogMessage.__Internal*) __Instance)->psz_header = Marshal.StringToHGlobalAnsi(value);
            }
        }

        public string PszMessage
        {
            get
            {
                return Marshal.PtrToStringAnsi(((global::VideoLAN.LibVLC.LogMessage.__Internal*) __Instance)->psz_message);
            }

            set
            {
                ((global::VideoLAN.LibVLC.LogMessage.__Internal*) __Instance)->psz_message = Marshal.StringToHGlobalAnsi(value);
            }
        }
    }

    public unsafe partial class deprecated
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_get_fps")]
            internal static extern float LibvlcMediaPlayerGetFps(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_set_agl")]
            internal static extern void LibvlcMediaPlayerSetAgl(global::System.IntPtr p_mi, uint drawable);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_get_agl")]
            internal static extern uint LibvlcMediaPlayerGetAgl(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_track_description_release")]
            internal static extern void LibvlcTrackDescriptionRelease(global::System.IntPtr p_track_description);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_get_height")]
            internal static extern int LibvlcVideoGetHeight(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_get_width")]
            internal static extern int LibvlcVideoGetWidth(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_get_title_description")]
            internal static extern global::System.IntPtr LibvlcVideoGetTitleDescription(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_get_chapter_description")]
            internal static extern global::System.IntPtr LibvlcVideoGetChapterDescription(global::System.IntPtr p_mi, int i_title);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_set_subtitle_file")]
            internal static extern int LibvlcVideoSetSubtitleFile(global::System.IntPtr p_mi, [MarshalAs(UnmanagedType.LPStr)] string psz_subtitle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_toggle_teletext")]
            internal static extern void LibvlcToggleTeletext(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_output_device_count")]
            internal static extern int LibvlcAudioOutputDeviceCount(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_audio_output);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_output_device_longname")]
            internal static extern sbyte* LibvlcAudioOutputDeviceLongname(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_output, int i_device);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_output_device_id")]
            internal static extern sbyte* LibvlcAudioOutputDeviceId(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_audio_output, int i_device);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_output_get_device_type")]
            internal static extern int LibvlcAudioOutputGetDeviceType(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_output_set_device_type")]
            internal static extern void LibvlcAudioOutputSetDeviceType(global::System.IntPtr p_mp, int device_type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_parse")]
            internal static extern void LibvlcMediaParse(global::System.IntPtr p_md);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_parse_async")]
            internal static extern void LibvlcMediaParseAsync(global::System.IntPtr p_md);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_is_parsed")]
            internal static extern int LibvlcMediaIsParsed(global::System.IntPtr p_md);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_get_tracks_info")]
            internal static extern int LibvlcMediaGetTracksInfo(global::System.IntPtr p_md, global::System.IntPtr tracks);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_add_file_content")]
            internal static extern int LibvlcMediaListAddFileContent(global::System.IntPtr p_ml, [MarshalAs(UnmanagedType.LPStr)] string psz_uri);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_discoverer_new_from_name")]
            internal static extern global::System.IntPtr LibvlcMediaDiscovererNewFromName(global::System.IntPtr p_inst, [MarshalAs(UnmanagedType.LPStr)] string psz_name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_discoverer_localized_name")]
            internal static extern sbyte* LibvlcMediaDiscovererLocalizedName(global::System.IntPtr p_mdis);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_discoverer_event_manager")]
            internal static extern global::System.IntPtr LibvlcMediaDiscovererEventManager(global::System.IntPtr p_mdis);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_wait")]
            internal static extern void LibvlcWait(global::System.IntPtr p_instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_get_log_verbosity")]
            internal static extern uint LibvlcGetLogVerbosity(global::System.IntPtr p_instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_set_log_verbosity")]
            internal static extern void LibvlcSetLogVerbosity(global::System.IntPtr p_instance, uint level);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_log_open")]
            internal static extern global::System.IntPtr LibvlcLogOpen(global::System.IntPtr p_instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_log_close")]
            internal static extern void LibvlcLogClose(global::System.IntPtr p_log);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_log_count")]
            internal static extern uint LibvlcLogCount(global::System.IntPtr p_log);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_log_clear")]
            internal static extern void LibvlcLogClear(global::System.IntPtr p_log);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_log_get_iterator")]
            internal static extern global::System.IntPtr LibvlcLogGetIterator(global::System.IntPtr p_log);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_log_iterator_free")]
            internal static extern void LibvlcLogIteratorFree(global::System.IntPtr p_iter);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_log_iterator_has_next")]
            internal static extern int LibvlcLogIteratorHasNext(global::System.IntPtr p_iter);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_log_iterator_next")]
            internal static extern global::System.IntPtr LibvlcLogIteratorNext(global::System.IntPtr p_iter, global::System.IntPtr p_buf);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_playlist_play")]
            internal static extern void LibvlcPlaylistPlay(global::System.IntPtr p_instance, int i_id, int i_options, sbyte** ppsz_options);
        }

        /// <summary>Get movie fps rate</summary>
        /// <param name="p_mi">the Media Player</param>
        /// <returns>frames per second (fps) for this playing movie, or 0 if unspecified</returns>
        /// <remarks>
        /// <para>This function is provided for backward compatibility. It cannot deal with</para>
        /// <para>multiple video tracks. In LibVLC versions prior to 3.0, it would also fail</para>
        /// <para>if the file format did not convey the frame rate explicitly.</para>
        /// <para>Consider using libvlc_media_tracks_get() instead.</para>
        /// </remarks>
        public static float LibvlcMediaPlayerGetFps(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerGetFps(__arg0);
            return __ret;
        }

        /// <remarks>Use libvlc_media_player_set_nsobject() instead</remarks>
        public static void LibvlcMediaPlayerSetAgl(global::VideoLAN.LibVLC.MediaPlayer p_mi, uint drawable)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcMediaPlayerSetAgl(__arg0, drawable);
        }

        /// <remarks>Use libvlc_media_player_get_nsobject() instead</remarks>
        public static uint LibvlcMediaPlayerGetAgl(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerGetAgl(__arg0);
            return __ret;
        }

        /// <remarks>Use libvlc_track_description_list_release() instead</remarks>
        public static void LibvlcTrackDescriptionRelease(global::VideoLAN.LibVLC.TrackDescription p_track_description)
        {
            var __arg0 = ReferenceEquals(p_track_description, null) ? global::System.IntPtr.Zero : p_track_description.__Instance;
            __Internal.LibvlcTrackDescriptionRelease(__arg0);
        }

        /// <summary>Get current video height.</summary>
        /// <param name="p_mi">the media player</param>
        /// <returns>the video pixel height or 0 if not applicable</returns>
        /// <remarks>Use libvlc_video_get_size() instead.</remarks>
        public static int LibvlcVideoGetHeight(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoGetHeight(__arg0);
            return __ret;
        }

        /// <summary>Get current video width.</summary>
        /// <param name="p_mi">the media player</param>
        /// <returns>the video pixel width or 0 if not applicable</returns>
        /// <remarks>Use libvlc_video_get_size() instead.</remarks>
        public static int LibvlcVideoGetWidth(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoGetWidth(__arg0);
            return __ret;
        }

        /// <summary>Get the description of available titles.</summary>
        /// <param name="p_mi">the media player</param>
        /// <returns>
        /// <para>list containing description of available titles.</para>
        /// <para>It must be freed with libvlc_track_description_list_release()</para>
        /// </returns>
        public static global::VideoLAN.LibVLC.TrackDescription LibvlcVideoGetTitleDescription(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoGetTitleDescription(__arg0);
            global::VideoLAN.LibVLC.TrackDescription __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::VideoLAN.LibVLC.TrackDescription.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::VideoLAN.LibVLC.TrackDescription) global::VideoLAN.LibVLC.TrackDescription.NativeToManagedMap[__ret];
            else __result0 = global::VideoLAN.LibVLC.TrackDescription.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Get the description of available chapters for specific title.</summary>
        /// <param name="p_mi">the media player</param>
        /// <param name="i_title">selected title</param>
        /// <returns>
        /// <para>list containing description of available chapter for title i_title.</para>
        /// <para>It must be freed with libvlc_track_description_list_release()</para>
        /// </returns>
        public static global::VideoLAN.LibVLC.TrackDescription LibvlcVideoGetChapterDescription(global::VideoLAN.LibVLC.MediaPlayer p_mi, int i_title)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoGetChapterDescription(__arg0, i_title);
            global::VideoLAN.LibVLC.TrackDescription __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::VideoLAN.LibVLC.TrackDescription.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::VideoLAN.LibVLC.TrackDescription) global::VideoLAN.LibVLC.TrackDescription.NativeToManagedMap[__ret];
            else __result0 = global::VideoLAN.LibVLC.TrackDescription.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Set new video subtitle file.</summary>
        /// <param name="p_mi">the media player</param>
        /// <param name="psz_subtitle">new video subtitle file</param>
        /// <returns>the success status (boolean)</returns>
        /// <remarks>Use libvlc_media_player_add_slave() instead.</remarks>
        public static int LibvlcVideoSetSubtitleFile(global::VideoLAN.LibVLC.MediaPlayer p_mi, string psz_subtitle)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoSetSubtitleFile(__arg0, psz_subtitle);
            return __ret;
        }

        /// <summary>Toggle teletext transparent status on video output.</summary>
        /// <param name="p_mi">the media player</param>
        /// <remarks>use libvlc_video_set_teletext() instead.</remarks>
        public static void LibvlcToggleTeletext(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcToggleTeletext(__arg0);
        }

        /// <summary>Backward compatibility stub. Do not use in new code.</summary>
        /// <returns>always 0.</returns>
        /// <remarks>Use libvlc_audio_output_device_list_get() instead.</remarks>
        public static int LibvlcAudioOutputDeviceCount(global::VideoLAN.LibVLC.Instance p_instance, string psz_audio_output)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcAudioOutputDeviceCount(__arg0, psz_audio_output);
            return __ret;
        }

        /// <summary>Backward compatibility stub. Do not use in new code.</summary>
        /// <returns>always NULL.</returns>
        /// <remarks>Use libvlc_audio_output_device_list_get() instead.</remarks>
        public static sbyte* LibvlcAudioOutputDeviceLongname(global::VideoLAN.LibVLC.Instance p_instance, string psz_output, int i_device)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcAudioOutputDeviceLongname(__arg0, psz_output, i_device);
            return __ret;
        }

        /// <summary>Backward compatibility stub. Do not use in new code.</summary>
        /// <returns>always NULL.</returns>
        /// <remarks>Use libvlc_audio_output_device_list_get() instead.</remarks>
        public static sbyte* LibvlcAudioOutputDeviceId(global::VideoLAN.LibVLC.Instance p_instance, string psz_audio_output, int i_device)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcAudioOutputDeviceId(__arg0, psz_audio_output, i_device);
            return __ret;
        }

        /// <summary>Stub for backward compatibility.</summary>
        /// <returns>always -1.</returns>
        public static int LibvlcAudioOutputGetDeviceType(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcAudioOutputGetDeviceType(__arg0);
            return __ret;
        }

        /// <summary>Stub for backward compatibility.</summary>
        public static void LibvlcAudioOutputSetDeviceType(global::VideoLAN.LibVLC.MediaPlayer p_mp, int device_type)
        {
            var __arg0 = ReferenceEquals(p_mp, null) ? global::System.IntPtr.Zero : p_mp.__Instance;
            __Internal.LibvlcAudioOutputSetDeviceType(__arg0, device_type);
        }

        /// <summary>Parse a media.</summary>
        /// <param name="p_md">media descriptor object</param>
        /// <remarks>
        /// <para>This fetches (local) art, meta data and tracks information.</para>
        /// <para>The method is synchronous.</para>
        /// <para>This function could block indefinitely.</para>
        /// <para>Use libvlc_media_parse_with_options() instead</para>
        /// <para>libvlc_media_parse_with_options</para>
        /// <para>libvlc_media_get_meta</para>
        /// <para>libvlc_media_get_tracks_info</para>
        /// </remarks>
        public static void LibvlcMediaParse(global::VideoLAN.LibVLC.Media p_md)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            __Internal.LibvlcMediaParse(__arg0);
        }

        /// <summary>Parse a media.</summary>
        /// <param name="p_md">media descriptor object</param>
        /// <remarks>
        /// <para>This fetches (local) art, meta data and tracks information.</para>
        /// <para>The method is the asynchronous of libvlc_media_parse().</para>
        /// <para>To track when this is over you can listen to libvlc_MediaParsedChanged</para>
        /// <para>event. However if the media was already parsed you will not receive this</para>
        /// <para>event.</para>
        /// <para>You can't be sure to receive the libvlc_MediaParsedChanged</para>
        /// <para>event (you can wait indefinitely for this event).</para>
        /// <para>Use libvlc_media_parse_with_options() instead</para>
        /// <para>libvlc_media_parse</para>
        /// <para>libvlc_MediaParsedChanged</para>
        /// <para>libvlc_media_get_meta</para>
        /// <para>libvlc_media_get_tracks_info</para>
        /// </remarks>
        public static void LibvlcMediaParseAsync(global::VideoLAN.LibVLC.Media p_md)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            __Internal.LibvlcMediaParseAsync(__arg0);
        }

        /// <summary>Return true is the media descriptor object is parsed</summary>
        /// <param name="p_md">media descriptor object</param>
        /// <returns>true if media object has been parsed otherwise it returns false</returns>
        /// <remarks>
        /// <para>This can return true in case of failure.</para>
        /// <para>Use libvlc_media_get_parsed_status() instead</para>
        /// <para>libvlc_MediaParsedChanged</para>
        /// </remarks>
        public static int LibvlcMediaIsParsed(global::VideoLAN.LibVLC.Media p_md)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            var __ret = __Internal.LibvlcMediaIsParsed(__arg0);
            return __ret;
        }

        /// <summary>Get media descriptor's elementary streams description</summary>
        /// <param name="p_md">media descriptor object</param>
        /// <param name="tracks">
        /// <para>address to store an allocated array of Elementary Streams</para>
        /// <para>descriptions (must be freed by the caller) [OUT]</para>
        /// </param>
        /// <returns>the number of Elementary Streams</returns>
        /// <remarks>
        /// <para>Note, you need to call libvlc_media_parse() or play the media at least once</para>
        /// <para>before calling this function.</para>
        /// <para>Not doing this will result in an empty array.</para>
        /// <para>Use libvlc_media_tracks_get() instead</para>
        /// </remarks>
        public static int LibvlcMediaGetTracksInfo(global::VideoLAN.LibVLC.Media p_md, global::VideoLAN.LibVLC.MediaTrackInfo tracks)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            var __arg1 = ReferenceEquals(tracks, null) ? global::System.IntPtr.Zero : tracks.__Instance;
            var __ret = __Internal.LibvlcMediaGetTracksInfo(__arg0, __arg1);
            return __ret;
        }

        /// <summary>@{</summary>
        public static int LibvlcMediaListAddFileContent(global::VideoLAN.LibVLC.MediaList p_ml, string psz_uri)
        {
            var __arg0 = ReferenceEquals(p_ml, null) ? global::System.IntPtr.Zero : p_ml.__Instance;
            var __ret = __Internal.LibvlcMediaListAddFileContent(__arg0, psz_uri);
            return __ret;
        }

        /// <remarks>Use libvlc_media_discoverer_new() and libvlc_media_discoverer_start().</remarks>
        public static global::VideoLAN.LibVLC.MediaDiscoverer LibvlcMediaDiscovererNewFromName(global::VideoLAN.LibVLC.Instance p_inst, string psz_name)
        {
            var __arg0 = ReferenceEquals(p_inst, null) ? global::System.IntPtr.Zero : p_inst.__Instance;
            var __ret = __Internal.LibvlcMediaDiscovererNewFromName(__arg0, psz_name);
            global::VideoLAN.LibVLC.MediaDiscoverer __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::VideoLAN.LibVLC.MediaDiscoverer.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::VideoLAN.LibVLC.MediaDiscoverer) global::VideoLAN.LibVLC.MediaDiscoverer.NativeToManagedMap[__ret];
            else __result0 = global::VideoLAN.LibVLC.MediaDiscoverer.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Get media service discover object its localized name.</summary>
        /// <param name="p_mdis">media discover object</param>
        /// <returns>localized name or NULL if the media_discoverer is not started</returns>
        /// <remarks>
        /// <para>Useless, use libvlc_media_discoverer_list_get() to get the</para>
        /// <para>longname of the service discovery.</para>
        /// </remarks>
        public static sbyte* LibvlcMediaDiscovererLocalizedName(global::VideoLAN.LibVLC.MediaDiscoverer p_mdis)
        {
            var __arg0 = ReferenceEquals(p_mdis, null) ? global::System.IntPtr.Zero : p_mdis.__Instance;
            var __ret = __Internal.LibvlcMediaDiscovererLocalizedName(__arg0);
            return __ret;
        }

        /// <summary>Get event manager from media service discover object.</summary>
        /// <param name="p_mdis">media service discover object</param>
        /// <returns>event manager object.</returns>
        /// <remarks>
        /// <para>Useless, media_discoverer events are only triggered when calling</para>
        /// <para>libvlc_media_discoverer_start() and libvlc_media_discoverer_stop().</para>
        /// </remarks>
        public static global::VideoLAN.LibVLC.EventManager LibvlcMediaDiscovererEventManager(global::VideoLAN.LibVLC.MediaDiscoverer p_mdis)
        {
            var __arg0 = ReferenceEquals(p_mdis, null) ? global::System.IntPtr.Zero : p_mdis.__Instance;
            var __ret = __Internal.LibvlcMediaDiscovererEventManager(__arg0);
            global::VideoLAN.LibVLC.EventManager __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::VideoLAN.LibVLC.EventManager.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::VideoLAN.LibVLC.EventManager) global::VideoLAN.LibVLC.EventManager.NativeToManagedMap[__ret];
            else __result0 = global::VideoLAN.LibVLC.EventManager.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Waits until an interface causes the instance to exit.</para>
        /// <para>You should start at least one interface first, using libvlc_add_intf().</para>
        /// </summary>
        /// <param name="p_instance">the instance</param>
        /// <remarks>
        /// <para>This function wastes one thread doing basically nothing.</para>
        /// <para>libvlc_set_exit_handler() should be used instead.</para>
        /// </remarks>
        public static void LibvlcWait(global::VideoLAN.LibVLC.Instance p_instance)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            __Internal.LibvlcWait(__arg0);
        }

        /// <summary>
        /// <para>Always returns minus one.</para>
        /// <para>This function is only provided for backward compatibility.</para>
        /// </summary>
        /// <param name="p_instance">ignored</param>
        /// <returns>always -1</returns>
        public static uint LibvlcGetLogVerbosity(global::VideoLAN.LibVLC.Instance p_instance)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcGetLogVerbosity(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>This function does nothing.</para>
        /// <para>It is only provided for backward compatibility.</para>
        /// </summary>
        /// <param name="p_instance">ignored</param>
        /// <param name="level">ignored</param>
        public static void LibvlcSetLogVerbosity(global::VideoLAN.LibVLC.Instance p_instance, uint level)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            __Internal.LibvlcSetLogVerbosity(__arg0, level);
        }

        /// <summary>
        /// <para>This function does nothing useful.</para>
        /// <para>It is only provided for backward compatibility.</para>
        /// </summary>
        /// <param name="p_instance">libvlc instance</param>
        /// <returns>an unique pointer or NULL on error</returns>
        public static global::VideoLAN.LibVLC.Log LibvlcLogOpen(global::VideoLAN.LibVLC.Instance p_instance)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcLogOpen(__arg0);
            global::VideoLAN.LibVLC.Log __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::VideoLAN.LibVLC.Log.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::VideoLAN.LibVLC.Log) global::VideoLAN.LibVLC.Log.NativeToManagedMap[__ret];
            else __result0 = global::VideoLAN.LibVLC.Log.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Frees memory allocated by libvlc_log_open().</summary>
        /// <param name="p_log">libvlc log instance or NULL</param>
        public static void LibvlcLogClose(global::VideoLAN.LibVLC.Log p_log)
        {
            var __arg0 = ReferenceEquals(p_log, null) ? global::System.IntPtr.Zero : p_log.__Instance;
            __Internal.LibvlcLogClose(__arg0);
        }

        /// <summary>
        /// <para>Always returns zero.</para>
        /// <para>This function is only provided for backward compatibility.</para>
        /// </summary>
        /// <param name="p_log">ignored</param>
        /// <returns>always zero</returns>
        public static uint LibvlcLogCount(global::VideoLAN.LibVLC.Log p_log)
        {
            var __arg0 = ReferenceEquals(p_log, null) ? global::System.IntPtr.Zero : p_log.__Instance;
            var __ret = __Internal.LibvlcLogCount(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>This function does nothing.</para>
        /// <para>It is only provided for backward compatibility.</para>
        /// </summary>
        /// <param name="p_log">ignored</param>
        public static void LibvlcLogClear(global::VideoLAN.LibVLC.Log p_log)
        {
            var __arg0 = ReferenceEquals(p_log, null) ? global::System.IntPtr.Zero : p_log.__Instance;
            __Internal.LibvlcLogClear(__arg0);
        }

        /// <summary>
        /// <para>This function does nothing useful.</para>
        /// <para>It is only provided for backward compatibility.</para>
        /// </summary>
        /// <param name="p_log">ignored</param>
        /// <returns>an unique pointer or NULL on error or if the parameter was NULL</returns>
        public static global::VideoLAN.LibVLC.LogIterator LibvlcLogGetIterator(global::VideoLAN.LibVLC.Log p_log)
        {
            var __arg0 = ReferenceEquals(p_log, null) ? global::System.IntPtr.Zero : p_log.__Instance;
            var __ret = __Internal.LibvlcLogGetIterator(__arg0);
            global::VideoLAN.LibVLC.LogIterator __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::VideoLAN.LibVLC.LogIterator.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::VideoLAN.LibVLC.LogIterator) global::VideoLAN.LibVLC.LogIterator.NativeToManagedMap[__ret];
            else __result0 = global::VideoLAN.LibVLC.LogIterator.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Frees memory allocated by libvlc_log_get_iterator().</summary>
        /// <param name="p_iter">libvlc log iterator or NULL</param>
        public static void LibvlcLogIteratorFree(global::VideoLAN.LibVLC.LogIterator p_iter)
        {
            var __arg0 = ReferenceEquals(p_iter, null) ? global::System.IntPtr.Zero : p_iter.__Instance;
            __Internal.LibvlcLogIteratorFree(__arg0);
        }

        /// <summary>
        /// <para>Always returns zero.</para>
        /// <para>This function is only provided for backward compatibility.</para>
        /// </summary>
        /// <param name="p_iter">ignored</param>
        /// <returns>always zero</returns>
        public static int LibvlcLogIteratorHasNext(global::VideoLAN.LibVLC.LogIterator p_iter)
        {
            var __arg0 = ReferenceEquals(p_iter, null) ? global::System.IntPtr.Zero : p_iter.__Instance;
            var __ret = __Internal.LibvlcLogIteratorHasNext(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Always returns NULL.</para>
        /// <para>This function is only provided for backward compatibility.</para>
        /// </summary>
        /// <param name="p_iter">libvlc log iterator or NULL</param>
        /// <param name="p_buf">ignored</param>
        /// <returns>always NULL</returns>
        public static global::VideoLAN.LibVLC.LogMessage LibvlcLogIteratorNext(global::VideoLAN.LibVLC.LogIterator p_iter, global::VideoLAN.LibVLC.LogMessage p_buf)
        {
            var __arg0 = ReferenceEquals(p_iter, null) ? global::System.IntPtr.Zero : p_iter.__Instance;
            var __arg1 = ReferenceEquals(p_buf, null) ? global::System.IntPtr.Zero : p_buf.__Instance;
            var __ret = __Internal.LibvlcLogIteratorNext(__arg0, __arg1);
            global::VideoLAN.LibVLC.LogMessage __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::VideoLAN.LibVLC.LogMessage.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::VideoLAN.LibVLC.LogMessage) global::VideoLAN.LibVLC.LogMessage.NativeToManagedMap[__ret];
            else __result0 = global::VideoLAN.LibVLC.LogMessage.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Start playing (if there is any item in the playlist).</summary>
        /// <param name="p_instance">the playlist instance</param>
        /// <param name="i_id">
        /// <para>the item to play. If this is a negative number, the next</para>
        /// <para>item will be selected. Otherwise, the item with the given ID will be</para>
        /// <para>played</para>
        /// </param>
        /// <param name="i_options">the number of options to add to the item</param>
        /// <param name="ppsz_options">the options to add to the item</param>
        /// <remarks>
        /// <para>Additionnal playlist item options can be specified for addition to the</para>
        /// <para>item before it is played.</para>
        /// </remarks>
        public static void LibvlcPlaylistPlay(global::VideoLAN.LibVLC.Instance p_instance, int i_id, int i_options, sbyte** ppsz_options)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            __Internal.LibvlcPlaylistPlay(__arg0, i_id, i_options, ppsz_options);
        }
    }

    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate void Action_IntPtr(global::System.IntPtr _0);
    }
}
